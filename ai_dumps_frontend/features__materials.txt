====================================================================================================
# FRONTEND FOLDER: features__materials
# ROOT PATH: C:\academyfront\src\features\materials
====================================================================================================


==========================================================================================
# FILE: index.ts
==========================================================================================
// PATH: src/features/materials/index.ts
export { default as MaterialsRoutes } from "./routes";


==========================================================================================
# FILE: routes.tsx
==========================================================================================
// PATH: src/features/materials/routes.tsx
import { Routes, Route, Navigate } from "react-router-dom";
import MaterialsLayout from "./layout/MaterialsLayout";
import SheetsListPage from "./sheets/SheetsListPage";
import ReportsPage from "./reports/ReportsPage";
import MessagesPage from "./messages/MessagesPage";

export default function MaterialsRoutes() {
  return (
    <Routes>
      <Route element={<MaterialsLayout />}>
        <Route index element={<Navigate to="sheets" replace />} />
        <Route path="sheets" element={<SheetsListPage />} />
        <Route path="reports" element={<ReportsPage />} />
        <Route path="messages" element={<MessagesPage />} />
      </Route>
    </Routes>
  );
}


==========================================================================================
# FILE: api/answerKeys.ts
==========================================================================================
// ======================================================================================
// FILE: src/features/materials/api/answerKeys.ts  (SSOT ALIGN: exams/answer-keys/?exam=<exam_id>)
// ======================================================================================
import api from "@/shared/api/axios";
import axios from "axios";

export type AnswerKeyEntity = {
  id: number;
  exam: number; // ✅ backend: AnswerKey.exam = template Exam.id
  answers: Record<string, string>; // key=ExamQuestion.id (string), value=correct answer
  created_at?: string;
  updated_at?: string;
};

function normalizeArray(data: any): any[] {
  if (Array.isArray(data)) return data;
  if (Array.isArray(data?.items)) return data.items;
  if (Array.isArray(data?.results)) return data.results;
  return [];
}

/**
 * ✅ SSOT (backend):
 * - list/retrieve: ?exam=<id> 로 접근 가능
 * - regular exam id를 넣어도 서버가 template로 resolve해서 단일진실 반환
 */
export async function getExamAnswerKey(examId: number): Promise<AnswerKeyEntity | null> {
  if (!Number.isFinite(examId) || examId <= 0) return null;

  try {
    const res = await api.get(`/exams/answer-keys/`, {
      params: { exam: examId },
    });

    const arr = normalizeArray(res.data);
    const first = arr?.[0];
    if (!first) return null;
    return first as AnswerKeyEntity;
  } catch (err: any) {
    if (axios.isAxiosError(err) && err.response?.status === 404) {
      return null;
    }
    throw err;
  }
}

/**
 * ✅ SSOT (backend):
 * - AnswerKey는 template exam에만 생성 가능
 * - 여기서는 caller가 template exam id를 넘기는 흐름(자료실=template list)로 사용
 */
export async function createAnswerKey(payload: {
  examId: number;
  answers: Record<string, string>;
}): Promise<AnswerKeyEntity> {
  const res = await api.post(`/exams/answer-keys/`, {
    exam: payload.examId,
    answers: payload.answers,
  });
  return res.data as AnswerKeyEntity;
}

export async function updateAnswerKey(payload: {
  id: number;
  examId: number;
  answers: Record<string, string>;
}): Promise<AnswerKeyEntity> {
  const res = await api.put(`/exams/answer-keys/${payload.id}/`, {
    exam: payload.examId,
    answers: payload.answers,
  });
  return res.data as AnswerKeyEntity;
}

export async function upsertExamAnswerKey(input: {
  examId: number;
  existingId?: number | null;
  answers: Record<string, string>;
}) {
  if (!Number.isFinite(input.examId) || input.examId <= 0) {
    throw new Error("유효하지 않은 examId");
  }

  if (input.existingId) {
    return await updateAnswerKey({
      id: input.existingId,
      examId: input.examId,
      answers: input.answers,
    });
  }

  return await createAnswerKey({
    examId: input.examId,
    answers: input.answers,
  });
}


==========================================================================================
# FILE: api/index.ts
==========================================================================================
// ======================================================================================
// FILE: src/features/materials/api/index.ts
// ======================================================================================
export * from "./sheets";
export * from "./sheetQuestions";
export * from "./answerKeys";


==========================================================================================
# FILE: api/sheetQuestions.ts
==========================================================================================
// ======================================================================================
// FILE: src/features/materials/api/sheetQuestions.ts  (SSOT ALIGN: /exams/<exam_id>/questions/)
// ======================================================================================
import api from "@/shared/api/axios";

export type SheetQuestionEntity = {
  id: number;
  sheet: number; // backend ExamQuestion.sheet (Sheet.id) — 프론트에서는 표시용으로만 사용
  number: number;
  score: number;
  image?: string | null;
  region_meta?: any; // backend stores bbox meta
  created_at?: string;
  updated_at?: string;
};

/**
 * ✅ SSOT (backend):
 * GET /api/v1/exams/<exam_id>/questions/
 * - exam_id가 regular여도 서버가 template로 resolve하여 단일진실 문항을 반환
 */
export async function getExamQuestions(examId: number): Promise<SheetQuestionEntity[]> {
  if (!Number.isFinite(examId) || examId <= 0) return [];

  const res = await api.get(`/exams/${examId}/questions/`);
  const data = res.data;

  if (Array.isArray(data)) return data as SheetQuestionEntity[];
  if (Array.isArray(data?.items)) return data.items as SheetQuestionEntity[];
  if (Array.isArray(data?.results)) return data.results as SheetQuestionEntity[];
  return [];
}

/**
 * ✅ SSOT (backend):
 * PATCH /api/v1/exams/questions/<question_id>/
 * - 수정은 template + editable(derived regular 없음)일 때만 허용
 */
export async function patchQuestionScore(input: {
  questionId: number;
  score: number;
}): Promise<SheetQuestionEntity> {
  const res = await api.patch(`/exams/questions/${input.questionId}/`, {
    score: input.score,
  });
  return res.data as SheetQuestionEntity;
}


==========================================================================================
# FILE: api/sheets.ts
==========================================================================================
// PATH: src/features/materials/api/sheets.ts
import api from "@/shared/api/axios";

export type SheetEntity = {
  id: number; // ✅ backend Exam.id (template/regular)
  title?: string | null;
  description?: string | null;
  subject?: string | null;
  exam_type?: "template" | "regular";
  is_active?: boolean | null;
  allow_retake?: boolean | null;
  max_attempts?: number | null;
  pass_score?: number | null;
  open_at?: string | null;
  close_at?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
};

function normalizeList(data: any): SheetEntity[] {
  if (Array.isArray(data)) return data as SheetEntity[];
  if (Array.isArray(data?.items)) return data.items as SheetEntity[];
  if (Array.isArray(data?.results)) return data.results as SheetEntity[];
  return [];
}

/**
 * materials(단일진실) 내부에서 "시험지 상품(=template exam)"을 조회/생성한다.
 * - 백엔드 엔드포인트는 /exams/
 * - SSOT: template exam이 Sheet/Question/AnswerKey/Asset의 단일 진실
 */
export async function listSheets(): Promise<SheetEntity[]> {
  // template만 자료실에 노출
  const res = await api.get("/exams/", { params: { exam_type: "template" } });
  return normalizeList(res.data);
}

export async function getSheet(sheetId: number): Promise<SheetEntity | null> {
  if (!Number.isFinite(sheetId) || sheetId <= 0) return null;
  const res = await api.get(`/exams/${sheetId}/`);
  return (res.data as any) ?? null;
}

export async function createSheet(input: {
  title: string;
  subject: string; // ✅ template 생성에는 subject 필수 (백엔드 계약)
  description?: string;
}): Promise<SheetEntity> {
  const res = await api.post("/exams/", {
    title: input.title,
    description: input.description ?? "",
    subject: input.subject,
    exam_type: "template",
  });

  const data = res.data as any;
  if (!data?.id) throw new Error("시험지 생성 실패");
  return data as SheetEntity;
}


==========================================================================================
# FILE: components/TemplateMaterialEditorModal.AssetsTab.tsx
==========================================================================================
// PATH: src/features/materials/components/TemplateMaterialEditorModal.AssetsTab.tsx
// NOTE:
// - assets 도메인은 더 이상 PDF 생성 API를 직접 노출하지 않는다.
// - OMR 생성은 exams 도메인 SSOT (/exams/<template_exam_id>/generate-omr/) 기준.
// - 이 탭은 유지하되, 현재 스펙 안내 + TODO로 대체한다.

export function AssetsTab({ templateExamId }: { templateExamId?: number }) {
  return (
    <div className="space-y-4">
      <div className="rounded border bg-yellow-50 p-4 text-sm">
        <div className="font-semibold mb-1">OMR 자산 생성 (안내)</div>
        <ul className="list-disc ml-5 space-y-1">
          <li>
            현재 스펙에서 OMR PDF 생성은 <b>assets</b>가 아닌{" "}
            <b>exams 도메인</b> 책임입니다.
          </li>
          <li>
            사용 API:{" "}
            <code className="px-1 bg-white border rounded">
              POST /exams/&lt;template_exam_id&gt;/generate-omr/
            </code>
          </li>
          <li>이 탭은 UX 일관성을 위해 유지됩니다.</li>
        </ul>
      </div>

      <div className="rounded border p-4 text-sm text-gray-600">
        <div className="font-semibold mb-1">TODO</div>
        <ul className="list-disc ml-5 space-y-1">
          <li>exams 자산 생성 API 상태 조회 표시</li>
          <li>생성 이력(assets list) 바로가기</li>
          <li>권한/락 상태에 따른 버튼 활성 제어</li>
        </ul>
      </div>

      {!templateExamId && (
        <div className="text-xs text-red-600">
          templateExamId가 없어 실제 생성은 비활성 상태입니다.
        </div>
      )}
    </div>
  );
}


==========================================================================================
# FILE: components/TemplateMaterialEditorModal.MetaPreviewTab.tsx
==========================================================================================
// PATH: src/features/materials/components/TemplateMaterialEditorModal.MetaPreviewTab.tsx
// NOTE:
// - objective_v1 meta 직접 조회 endpoint는 현재 assets에 존재하지 않는다.
// - 메타는 OMR 생성 시점에 외부/워커에서 생성되어 소비된다.
// - 이 탭은 유지하되, 스펙 안내 + TODO로 대체한다.

export function MetaPreviewTab() {
  return (
    <div className="space-y-4">
      <div className="rounded border bg-yellow-50 p-4 text-sm">
        <div className="font-semibold mb-1">OMR 메타데이터 (안내)</div>
        <ul className="list-disc ml-5 space-y-1">
          <li>
            현재 스펙에서 <b>assets는 메타를 생성/계산하지 않습니다.</b>
          </li>
          <li>
            메타는 OMR PDF와 1:1 대응되는 외부 산출물로,
            채점/인식 파이프라인에서 소비됩니다.
          </li>
          <li>
            프론트에서 임의 생성·추정·가공은 금지됩니다.
          </li>
        </ul>
      </div>

      <div className="rounded border p-4 text-sm text-gray-600">
        <div className="font-semibold mb-1">TODO</div>
        <ul className="list-disc ml-5 space-y-1">
          <li>exams/submissions에서 확정된 meta read-only 조회 연결</li>
          <li>PDF 자산과 연결된 meta 버전 표시</li>
        </ul>
      </div>
    </div>
  );
}


==========================================================================================
# FILE: components/TemplateMaterialEditorModal.tsx
==========================================================================================
// PATH: src/features/materials/components/TemplateMaterialEditorModal.tsx
// WHY:
// 템플릿 시험의 OMR 자산 편집을 단일 진입점에서 완결하기 위한 공용 모달.
// assets 도메인(PDF/meta)을 소비만 하며, 시험/채점 책임을 넘지 않는다.
// 이 모달 하나로 운영자가 “생성 → 확인 → 안내” 흐름을 끝낸다.

import { useState } from "react";
import { createPortal } from "react-dom";
import { AssetsTab } from "./TemplateMaterialEditorModal.AssetsTab";
import { MetaPreviewTab } from "./TemplateMaterialEditorModal.MetaPreviewTab";

type TabKey = "assets" | "meta" | "guide";

interface Props {
  open: boolean;
  onClose: () => void;
}

export function TemplateMaterialEditorModal({ open, onClose }: Props) {
  const [tab, setTab] = useState<TabKey>("assets");

  if (!open) return null;

  return createPortal(
    <div className="fixed inset-0 z-50 bg-black/40 flex items-center justify-center">
      <div className="bg-white w-[920px] max-h-[90vh] rounded shadow flex flex-col">
        <header className="px-6 py-4 border-b flex items-center justify-between">
          <h2 className="text-lg font-semibold">OMR 템플릿 자산</h2>
          <button onClick={onClose} className="text-sm text-gray-500">
            닫기
          </button>
        </header>

        <nav className="px-6 pt-3 flex gap-4 text-sm">
          <button onClick={() => setTab("assets")} className={tab === "assets" ? "font-semibold" : ""}>
            자산
          </button>
          <button onClick={() => setTab("meta")} className={tab === "meta" ? "font-semibold" : ""}>
            구조 정보
          </button>
          <button onClick={() => setTab("guide")} className={tab === "guide" ? "font-semibold" : ""}>
            안내
          </button>
        </nav>

        <section className="px-6 py-4 overflow-auto flex-1">
          {tab === "assets" && <AssetsTab />}
          {tab === "meta" && <MetaPreviewTab />}
          {tab === "guide" && (
            <div className="space-y-2 text-sm">
              <p>이 시험지는 템플릿 단일진실 기반 OMR 답안지입니다.</p>
              <p>스캔/촬영 인식 안정성을 위해 레이아웃 수정은 허용되지 않습니다.</p>
              <p>정답, 채점, 결과는 다른 도메인의 책임입니다.</p>
            </div>
          )}
        </section>
      </div>
    </div>,
    document.body
  );
}


==========================================================================================
# FILE: layout/MaterialsLayout.tsx
==========================================================================================
// PATH: src/features/materials/layout/MaterialsLayout.tsx
// Students UI SSOT — Domain Header + ds-tabs + panel

import { Outlet } from "react-router-dom";
import { DomainLayout } from "@/shared/ui/layout";

const MATERIALS_TABS = [
  { key: "sheets", label: "시험지", path: "/admin/materials/sheets" },
  { key: "reports", label: "성적표", path: "/admin/materials/reports" },
  { key: "messages", label: "메시지", path: "/admin/materials/messages" },
];

export default function MaterialsLayout() {
  return (
    <DomainLayout
      title="자료실"
      description="시험지 · 성적표 · 메시지"
      tabs={MATERIALS_TABS}
    >
      <Outlet />
    </DomainLayout>
  );
}


==========================================================================================
# FILE: messages/MessagesPage.tsx
==========================================================================================
// PATH: src/features/materials/messages/MessagesPage.tsx
import { Section, Panel, EmptyState } from "@/shared/ui/ds";

export default function MessagesPage() {
  return (
    <Section>
      <Panel>
        <div className="panel-body">
          <EmptyState
            title="메시지"
            description="아직 구현되지 않은 기능입니다."
          />
        </div>
      </Panel>
    </Section>
  );
}


==========================================================================================
# FILE: reports/ReportsPage.tsx
==========================================================================================
// PATH: src/features/materials/reports/ReportsPage.tsx
import { Section, Panel, EmptyState } from "@/shared/ui/ds";

export default function ReportsPage() {
  return (
    <Section>
      <Panel>
        <div className="panel-body">
          <EmptyState
            title="성적표"
            description="아직 구현되지 않은 기능입니다."
          />
        </div>
      </Panel>
    </Section>
  );
}


==========================================================================================
# FILE: sheets/SheetsListPage.tsx
==========================================================================================
// PATH: src/features/materials/sheets/SheetsListPage.tsx
import { useMemo, useState } from "react";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { Button, EmptyState, Panel, Section } from "@/shared/ui/ds";
import { listSheetsApi, type SheetEntity } from "./sheets.api";
import { SheetsEditorModal } from "./components/editor/SheetsEditorModal";
import { SheetsCreateModal } from "./components/SheetsCreateModal";

export default function SheetsListPage() {
  const qc = useQueryClient();
  const [editingId, setEditingId] = useState<number | null>(null);
  const [createOpen, setCreateOpen] = useState(false);

  const sheetsQ = useQuery({
    queryKey: ["materials-sheets"],
    queryFn: listSheetsApi,
  });

  const items = useMemo(() => sheetsQ.data ?? [], [sheetsQ.data]);

  return (
    <Section>
      <Panel>
        <div className="panel-body space-y-4">
          <div className="flex items-center justify-between">
            <div>
              <div className="text-sm font-semibold">시험지</div>
              <div className="text-xs text-[var(--text-muted)]">
                시험 전에 제작되는 템플릿 시험지 목록
              </div>
            </div>

            <Button type="button" intent="primary" size="md" onClick={() => setCreateOpen(true)}>
              + 시험지 생성
            </Button>
          </div>

          {items.length === 0 && !sheetsQ.isLoading && (
            <EmptyState
              title="시험지가 없습니다"
              description="시험지를 먼저 생성하세요."
            />
          )}

          {items.length > 0 && (
            <table className="table">
              <thead>
                <tr>
                  <th>ID</th>
                  <th>시험지 이름</th>
                  <th>편집</th>
                </tr>
              </thead>
              <tbody>
                {items.map((s: SheetEntity) => (
                  <tr key={s.id}>
                    <td>#{s.id}</td>
                    <td>{s.title}</td>
                    <td>
                      <Button type="button" intent="secondary" size="sm" onClick={() => setEditingId(s.id)}>
                        편집
                      </Button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          )}
        </div>
      </Panel>

      <SheetsCreateModal
        open={createOpen}
        onClose={() => setCreateOpen(false)}
        onCreated={(sheet) => {
          qc.invalidateQueries({ queryKey: ["materials-sheets"] });
          setCreateOpen(false);
          setEditingId(sheet.id);
        }}
      />

      {editingId !== null && (
        <SheetsEditorModal
          open
          sheetId={editingId}
          onClose={() => setEditingId(null)}
        />
      )}
    </Section>
  );
}


==========================================================================================
# FILE: sheets/sheets.api.ts
==========================================================================================
// PATH: src/features/materials/sheets/sheets.api.ts
import api from "@/shared/api/axios";
import axios from "axios";

import {
  listSheets,
  getSheet,
  createSheet,
  type SheetEntity,
} from "@/features/materials/api/sheets";

import {
  getExamQuestions,
  patchQuestionScore,
  type SheetQuestionEntity,
} from "@/features/materials/api/sheetQuestions";

import {
  getExamAnswerKey,
  upsertExamAnswerKey,
  type AnswerKeyEntity,
} from "@/features/materials/api/answerKeys";

// ✅ Submissions domain SSOT wrapper (materials 내부에서만 사용)
import {
  listExamSubmissionsApi,
  manualEditSubmissionApi,
  retrySubmissionApi,
  uploadOmrBatchApi,
  type ExamSubmissionRow,
  type SubmissionManualEditInput,
} from "./components/submissions/submissions.api";

/* =====================================================================================
 * TYPES
 * ===================================================================================== */

export type { SheetEntity, SheetQuestionEntity, AnswerKeyEntity };

// ✅ submissions tab types re-export (Sheets 탭에서 사용)
export type { ExamSubmissionRow, SubmissionManualEditInput };

/**
 * ✅ SSOT (backend commentary in exams):
 * - OMR meta/layout/좌표 SSOT는 assets endpoint
 * - exams는 question_count를 확정하고 assets meta를 참조/소비
 *
 * 현재 프론트는 auto-questions(문항 bbox 생성) 목적으로 meta를 사용하되,
 * exams의 운영 스펙에 맞춰 question_count는 10|20|30만 허용한다.
 *
 * objective_v1 meta는 최소한 아래 필드를 가진다:
 * {
 *   version: "objective_v1",
 *   question_count: number,
 *   page: {...},
 *   identifier: ...,
 *   questions: [{ question_number, axis, roi:{x,y,w,h}, choices:[...] }]
 * }
 */
export type OmrObjectiveMetaV1 = {
  version: "objective_v1" | string;
  units?: string;
  question_count: number;
  page?: any;
  identifier?: any;
  questions: Array<{
    question_number: number;
    axis?: "x" | "y";
    roi: { x: number; y: number; w: number; h: number };
    choices?: any[];
  }>;
};

export type TemplateEditorSummary = {
  exam_id: number;
  title: string;
  subject: string;
  sheet_id: number;
  total_questions: number;
  has_answer_key: boolean;
  is_locked: boolean;
};

export type TemplateValidationResult =
  | { template_exam_id: number; ok: true }
  | { template_exam_id: number; ok: false; reason: string };

export type ExamAssetEntity = {
  id: number;
  exam: number;
  asset_type: "problem_pdf" | "omr_sheet";
  file_key: string;
  file_type?: string | null;
  file_size?: number | null;
  download_url?: string | null;
  created_at?: string;
  updated_at?: string;
};

/* =====================================================================================
 * INTERNAL HELPERS
 * ===================================================================================== */

function pickSheetId(anyData: any): number | null {
  const candidates = [
    anyData?.sheet_id,
    anyData?.sheetId,
    anyData?.sheet?.id,
    anyData?.sheet?.pk,
    anyData?.sheet?.sheet_id,
  ];

  for (const c of candidates) {
    const n = Number(c);
    if (Number.isFinite(n) && n > 0) return n;
  }
  return null;
}

async function resolveSheetIdByExamId(examId: number): Promise<number> {
  // 1) template-editor가 살아있으면 가장 확실
  const summary = await getTemplateEditorSummaryApi(examId).catch(() => null);
  const s1 = pickSheetId(summary);
  if (s1) return s1;

  // 2) exam detail에서 sheet_id 추출 시도(서버가 내려주는 경우만)
  const res = await api.get(`/exams/${examId}/`);
  const s2 = pickSheetId(res.data);
  if (s2) return s2;

  throw new Error("sheet_id를 찾을 수 없습니다. (builder 초기화/서버 응답 확인 필요)");
}

function buildQuestionRoiBoxesFromMetaV1(meta: OmrObjectiveMetaV1): Array<[number, number, number, number]> {
  // ✅ exams auto-questions는 boxes([x,y,w,h])를 받는다.
  // ✅ objective_v1 meta는 question 단위 roi를 제공하므로 그대로 변환한다.
  const boxes: Array<[number, number, number, number]> = [];

  for (const q of meta.questions ?? []) {
    const roi = q?.roi;
    if (!roi) continue;

    const x = Number(roi.x);
    const y = Number(roi.y);
    const w = Number(roi.w);
    const h = Number(roi.h);

    if (![x, y, w, h].every((n) => Number.isFinite(n))) continue;

    // backend serializer는 integer로 받는다.
    boxes.push([Math.round(x), Math.round(y), Math.round(w), Math.round(h)]);
  }

  return boxes;
}

async function postAutoQuestionsBySheetId(sheetId: number, questionCount: 10 | 20 | 30) {
  const meta = await fetchOmrObjectiveMeta(questionCount);

  const boxes = buildQuestionRoiBoxesFromMetaV1(meta);

  await api.post(`/exams/sheets/${sheetId}/auto-questions/`, {
    boxes,
  });
}

/* =====================================================================================
 * SHEETS (TEMPLATE EXAM = MATERIALS SSOT)
 * ===================================================================================== */

export async function listSheetsApi(): Promise<SheetEntity[]> {
  return await listSheets();
}

export async function getSheetApi(sheetId: number): Promise<SheetEntity | null> {
  return await getSheet(sheetId);
}

export async function createSheetApi(input: {
  title: string;
  subject: string;
  questionCount: 10 | 20 | 30;
  mode: "preset" | "custom";
}): Promise<SheetEntity> {
  if (input.mode !== "preset") {
    throw new Error("커스텀 업로드는 아직 비활성화되어 있습니다.");
  }

  // 1) template exam 생성 (SSOT)
  const created = await createSheet({
    title: input.title,
    subject: input.subject,
  });

  const examId = Number((created as any)?.id);
  if (!Number.isFinite(examId) || examId <= 0) {
    throw new Error("시험지 생성 실패");
  }

  // 2) builder로 sheet/answer_key 등 초기화 (SSOT)
  const builderRes = await api.post(`/exams/${examId}/builder/`);
  const builderData = builderRes?.data;

  // 3) sheet_id 확보 (builder 우선)
  const sheetId =
    pickSheetId(builderData) ||
    pickSheetId(created) ||
    (await resolveSheetIdByExamId(examId));

  // 4) preset이면 meta(assets objective_v1) 기반 문항 자동 생성
  await postAutoQuestionsBySheetId(sheetId, input.questionCount);

  return created;
}

/* =====================================================================================
 * QUESTIONS / ANSWERS
 * ===================================================================================== */

export async function getSheetQuestionsApi(examId: number): Promise<SheetQuestionEntity[]> {
  return await getExamQuestions(examId);
}

export async function patchSheetQuestionScoreApi(input: { questionId: number; score: number }) {
  return await patchQuestionScore(input);
}

export async function getSheetAnswerKeyApi(examId: number): Promise<AnswerKeyEntity | null> {
  return await getExamAnswerKey(examId);
}

export async function upsertSheetAnswerKeyApi(input: {
  sheetId: number; // historical name: 실제로는 examId를 받는다(자료실은 template list)
  existingId?: number | null;
  answers: Record<string, string>;
}) {
  return await upsertExamAnswerKey({
    examId: input.sheetId,
    existingId: input.existingId,
    answers: input.answers,
  });
}

/* =====================================================================================
 * TEMPLATE STATUS
 * ===================================================================================== */

export async function getTemplateEditorSummaryApi(examId: number): Promise<TemplateEditorSummary | null> {
  try {
    const res = await api.get(`/exams/${examId}/template-editor/`);
    return res.data as TemplateEditorSummary;
  } catch (err: any) {
    if (axios.isAxiosError(err)) {
      const s = err.response?.status;
      if (s === 400 || s === 404) return null;
    }
    throw err;
  }
}

export async function getTemplateValidationApi(examId: number): Promise<TemplateValidationResult | null> {
  try {
    const res = await api.get(`/exams/${examId}/template-validation/`);
    return res.data as TemplateValidationResult;
  } catch (err: any) {
    if (axios.isAxiosError(err)) {
      const s = err.response?.status;
      if (s === 400 || s === 404) return null;
    }
    throw err;
  }
}

/* =====================================================================================
 * ASSETS (OMR / PROBLEM PDF) — exams endpoints
 * ===================================================================================== */

export async function listExamAssetsApi(examId: number): Promise<ExamAssetEntity[]> {
  const res = await api.get(`/exams/${examId}/assets/`);
  const data = res.data;
  if (Array.isArray(data)) return data;
  if (Array.isArray(data?.items)) return data.items;
  if (Array.isArray(data?.results)) return data.results;
  return [];
}

export async function uploadExamAssetApi(input: {
  examId: number;
  assetType: "problem_pdf";
  file: File;
}): Promise<ExamAssetEntity> {
  const fd = new FormData();
  fd.append("asset_type", input.assetType);
  fd.append("file", input.file);

  const res = await api.post(`/exams/${input.examId}/assets/`, fd, {
    headers: { "Content-Type": "multipart/form-data" },
  });
  return res.data as ExamAssetEntity;
}

/**
 * ✅ SSOT (backend exams):
 * POST /exams/<template_exam_id>/generate-omr/
 * - question_count: 10|20|30
 */
export async function generateOmrSheetAssetApi(input: {
  templateExamId: number;
  questionCount: 10 | 20 | 30;
}): Promise<ExamAssetEntity> {
  const res = await api.post(`/exams/${input.templateExamId}/generate-omr/`, {
    question_count: input.questionCount,
  });
  return res.data as ExamAssetEntity;
}

/**
 * ✅ "문항 없음" 상태를 운영자 화면에서 즉시 복구하기 위한 버튼 API
 * - exams auto-questions는 sheet_id가 필요하므로, template-editor를 통해 sheet_id를 resolve한다.
 * - questionCount는 10|20|30만 허용(운영 스펙)
 */
export async function autoGenerateQuestionsApi(input: {
  templateExamId: number;
  questionCount: 10 | 20 | 30;
}) {
  const sheetId = await resolveSheetIdByExamId(input.templateExamId);
  await postAutoQuestionsBySheetId(sheetId, input.questionCount);
  return { sheetId };
}

/* =====================================================================================
 * META (assets objective_v1) — UI/auto-questions 입력용
 * ===================================================================================== */

export async function fetchOmrObjectiveMeta(questionCount: 10 | 20 | 30): Promise<OmrObjectiveMetaV1> {
  const res = await fetch(`/api/v1/assets/omr/objective/meta/?question_count=${questionCount}`, {
    credentials: "include",
  });
  if (!res.ok) throw new Error(await res.text());
  return (await res.json()) as OmrObjectiveMetaV1;
}

/* =====================================================================================
 * SUBMISSIONS (domains/submissions SSOT)
 * ===================================================================================== */

export async function listExamSubmissions(examId: number) {
  return await listExamSubmissionsApi(examId);
}

export async function manualEditSubmission(input: SubmissionManualEditInput) {
  return await manualEditSubmissionApi(input);
}

export async function retrySubmission(submissionId: number) {
  return await retrySubmissionApi(submissionId);
}

export async function uploadOmrBatch(input: { examId: number; files: File[]; sheetId?: number | string | null }) {
  return await uploadOmrBatchApi(input);
}


==========================================================================================
# FILE: sheets/components/OmrTemplateModal.tsx
==========================================================================================
// ====================================================================================================
// FILE: src/features/materials/sheets/components/OmrTemplateModal.tsx
// NOTE: 외부 의존(서브미션 모듈) 재사용. 이 파일은 이 폴더 SSOT 범위 내에서만 보존.
// ====================================================================================================
import OmrTemplateGeneratorPanel from "@/features/submissions/components/OmrTemplateGeneratorPanel";

export default function OmrTemplateModal({
  open,
  onClose,
  examId,
}: {
  open: boolean;
  onClose: () => void;
  examId: number;
}) {
  if (!open) return null;

  return (
    <div className="fixed inset-0 z-50 bg-black/60 flex items-center justify-center p-4">
      <div className="w-full max-w-xl rounded-xl border bg-[var(--bg-surface)] shadow-lg">
        <div className="flex items-center justify-between px-4 py-3 border-b">
          <div className="text-sm font-semibold">OMR 답안지 생성</div>
          <button className="text-xs text-[var(--text-muted)]" onClick={onClose}>
            닫기
          </button>
        </div>

        <div className="p-4">
          {/* ✅ 기존에 이미 검증된 구현 재사용 */}
          <OmrTemplateGeneratorPanel examId={examId} />
        </div>
      </div>
    </div>
  );
}


==========================================================================================
# FILE: sheets/components/SheetsCreateModal.tsx
==========================================================================================
// PATH: src/features/materials/sheets/components/SheetsCreateModal.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import { createPortal } from "react-dom";
import { useMutation } from "@tanstack/react-query";
import { Button } from "@/shared/ui/ds";
import { createSheetApi, type SheetEntity } from "../sheets.api";

type Props = {
  open: boolean;
  onClose: () => void;
  onCreated: (sheet: SheetEntity) => void;
};

const QUESTION_COUNTS = [10, 20, 30] as const;

export function SheetsCreateModal({ open, onClose, onCreated }: Props) {
  const panelRef = useRef<HTMLDivElement | null>(null);

  const [title, setTitle] = useState("");
  const [subject, setSubject] = useState("");
  const [questionCount, setQuestionCount] = useState<(typeof QUESTION_COUNTS)[number]>(20);

  const canCreate = useMemo(() => subject.trim().length > 0, [subject]);

  useEffect(() => {
    if (!open) return;
    const onKey = (e: KeyboardEvent) => {
      if (e.key === "Escape") onClose();
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [open, onClose]);

  const createMut = useMutation({
    mutationFn: async () =>
      createSheetApi({
        title: title.trim() || "제목 없는 시험지",
        subject: subject.trim(),
        questionCount,
        mode: "preset",
      }),
    onSuccess: (sheet) => {
      onCreated(sheet);
      setTitle("");
      setSubject("");
      setQuestionCount(20);
    },
    onError: (e: any) => {
      alert(e?.message || "시험지 생성 실패");
    },
  });

  if (!open) return null;

  return createPortal(
    <div
      className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center p-4"
      onMouseDown={(e) => {
        if (e.target === e.currentTarget) onClose();
      }}
    >
      <div
        ref={panelRef}
        className="w-full max-w-xl rounded-xl bg-white shadow-lg border"
      >
        <div className="px-4 py-3 border-b flex justify-between items-center">
          <div className="font-semibold">시험지 생성</div>
          <Button type="button" intent="ghost" size="sm" onClick={onClose}>닫기</Button>
        </div>

        <div className="p-4 space-y-4">
          <input
            className="input w-full"
            placeholder="시험지 이름"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
          />

          <input
            className="input w-full"
            placeholder="과목 (필수)"
            value={subject}
            onChange={(e) => setSubject(e.target.value)}
          />

          <div className="flex gap-2">
            {QUESTION_COUNTS.map((qc) => (
              <Button
                key={qc}
                type="button"
                intent={questionCount === qc ? "primary" : "secondary"}
                size="sm"
                onClick={() => setQuestionCount(qc)}
              >
                {qc}
              </Button>
            ))}
          </div>

          <div className="flex justify-end gap-2">
            <Button type="button" intent="secondary" size="md" onClick={onClose}>취소</Button>
            <Button
              type="button"
              intent="primary"
              size="md"
              disabled={!canCreate || createMut.isPending}
              onClick={() => createMut.mutate()}
            >
              {createMut.isPending ? "생성 중..." : "생성"}
            </Button>
          </div>
        </div>
      </div>
    </div>,
    document.body
  );
}


==========================================================================================
# FILE: sheets/components/TemplateMaterialEditorModal.AssetsTab.tsx
==========================================================================================
// PATH: src/features/materials/components/TemplateMaterialEditorModal.tsx
// SSOT ALIGN:
// - OMR/자산 생성은 exams 도메인(/exams/*) 기준으로 동작한다.
// - meta preview는 assets meta endpoint를 그대로 보여준다(가공 금지).

import { useState } from "react";
import { createPortal } from "react-dom";
import { AssetsTab } from "./TemplateMaterialEditorModal.AssetsTab";
import { MetaPreviewTab } from "./TemplateMaterialEditorModal.MetaPreviewTab";

type TabKey = "assets" | "meta" | "guide";

interface Props {
  open: boolean;
  onClose: () => void;
  templateExamId?: number; // ✅ optional (기존 호출부 안전)
}

export function TemplateMaterialEditorModal({ open, onClose, templateExamId }: Props) {
  const [tab, setTab] = useState<TabKey>("assets");

  if (!open) return null;

  return createPortal(
    <div className="fixed inset-0 z-50 bg-black/40 flex items-center justify-center">
      <div className="bg-white w-[920px] max-h-[90vh] rounded shadow flex flex-col">
        <header className="px-6 py-4 border-b flex items-center justify-between">
          <h2 className="text-lg font-semibold">OMR 템플릿 자산</h2>
          <button onClick={onClose} className="text-sm text-gray-500">
            닫기
          </button>
        </header>

        <nav className="px-6 pt-3 flex gap-4 text-sm">
          <button onClick={() => setTab("assets")} className={tab === "assets" ? "font-semibold" : ""}>
            자산
          </button>
          <button onClick={() => setTab("meta")} className={tab === "meta" ? "font-semibold" : ""}>
            구조 정보
          </button>
          <button onClick={() => setTab("guide")} className={tab === "guide" ? "font-semibold" : ""}>
            안내
          </button>
        </nav>

        <section className="px-6 py-4 overflow-auto flex-1">
          {tab === "assets" && <AssetsTab templateExamId={templateExamId} />}
          {tab === "meta" && <MetaPreviewTab />}
          {tab === "guide" && (
            <div className="space-y-2 text-sm">
              <p>이 시험지는 템플릿 단일진실 기반 OMR 답안지입니다.</p>
              <p>운영 시험(regular)에서는 템플릿 구조(문항/정답/자산)를 직접 수정할 수 없습니다.</p>
              <p>정답, 채점, 결과는 다른 도메인의 책임입니다.</p>
            </div>
          )}
        </section>
      </div>
    </div>,
    document.body
  );
}


==========================================================================================
# FILE: sheets/components/TemplateMaterialEditorModal.MetaPreviewTab.tsx
==========================================================================================
// PATH: src/features/materials/components/TemplateMaterialEditorModal.MetaPreviewTab.tsx
// SSOT ALIGN:
// - exams는 meta를 직접 생성하지 않고(코멘트 기준) assets의 objective_v1 meta를 참조한다.
// - 프론트는 meta를 "가공/추정"하지 않고 그대로 보여준다.
// - exams generate-omr/question_auto는 10|20|30 스펙에 맞춘다.

import { useEffect, useState } from "react";

const QUESTION_COUNTS = [10, 20, 30] as const;

export function MetaPreviewTab() {
  const [questionCount, setQuestionCount] = useState<(typeof QUESTION_COUNTS)[number]>(20);
  const [data, setData] = useState<any>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let alive = true;
    (async () => {
      try {
        setError(null);
        const res = await fetch(
          `/api/v1/assets/omr/objective/meta/?question_count=${questionCount}`,
          { credentials: "include" }
        );
        if (!res.ok) throw new Error(await res.text());
        const json = await res.json();
        if (alive) setData(json);
      } catch (e: any) {
        if (alive) setError(e?.message || "meta 조회 실패");
      }
    })();
    return () => {
      alive = false;
    };
  }, [questionCount]);

  return (
    <div className="space-y-3">
      <div className="flex gap-2">
        {QUESTION_COUNTS.map((qc) => (
          <button
            key={qc}
            onClick={() => setQuestionCount(qc)}
            className={`px-2 py-1 border rounded ${
              questionCount === qc ? "bg-black text-white" : ""
            }`}
          >
            {qc}
          </button>
        ))}
      </div>

      <p className="text-xs text-gray-600">
        이 정보는 백엔드가 반환하는 OMR 메타데이터 원본입니다. 프론트에서 수정하지 않습니다.
      </p>

      {error && <div className="text-sm text-red-600">{error}</div>}

      {data && (
        <pre className="text-xs bg-gray-100 p-3 rounded overflow-auto max-h-[400px]">
{JSON.stringify(data, null, 2)}
        </pre>
      )}
    </div>
  );
}


==========================================================================================
# FILE: sheets/components/editor/SheetsEditorBody.tsx
==========================================================================================
// ====================================================================================================
// FILE: src/features/materials/sheets/components/editor/SheetsEditorBody.tsx
// ====================================================================================================
// SSOT ALIGN:
// - Materials(Sheets) 화면은 template Exam.id를 기준으로 편집한다.
// - Submissions 도메인 연동(제출 목록/수동수정/재시도)을 "Sheet 탭" 안에서 운영자가 처리할 수 있게 한다.
// - Submissions list: GET /submissions/exams/<exam_id>/
// - Manual edit: POST /submissions/submissions/<submission_id>/manual-edit/
// - Retry: POST /submissions/submissions/<submission_id>/retry/

import { useEffect, useMemo, useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { EmptyState } from "@/shared/ui/ds";
import {
  getSheetApi,
  getSheetQuestionsApi,
  getSheetAnswerKeyApi,
  patchSheetQuestionScoreApi,
  upsertSheetAnswerKeyApi,
  listExamAssetsApi,
  generateOmrSheetAssetApi,
  autoGenerateQuestionsApi,
  type SheetQuestionEntity,
} from "../../sheets.api";

import SheetsSubmissionsTab from "../submissions/SheetsSubmissionsTab";

const CHOICES = ["A", "B", "C", "D", "E"] as const;
const QUESTION_COUNTS = [10, 20, 30] as const;

type TabKey = "editor" | "submissions";

export default function SheetsEditorBody({ sheetId }: { sheetId: number }) {
  const id = Number(sheetId); // ✅ 실제로는 template Exam.id
  const qc = useQueryClient();

  const [tab, setTab] = useState<TabKey>("editor");

  const sheetQ = useQuery({
    queryKey: ["materials-sheet", id],
    queryFn: () => getSheetApi(id),
    enabled: id > 0,
  });

  const qQ = useQuery({
    queryKey: ["materials-sheet-questions", id],
    queryFn: () => getSheetQuestionsApi(id),
    enabled: id > 0,
  });

  const akQ = useQuery({
    queryKey: ["materials-sheet-answerkey", id],
    queryFn: () => getSheetAnswerKeyApi(id),
    enabled: id > 0,
  });

  const assetsQ = useQuery({
    queryKey: ["materials-sheet-assets", id],
    queryFn: () => listExamAssetsApi(id),
    enabled: id > 0,
  });

  const questions = useMemo(
    () => (qQ.data ?? []).slice().sort((a, b) => a.number - b.number),
    [qQ.data]
  );

  // ✅ AnswerKey payload: key=ExamQuestion.id (string)
  const [answers, setAnswers] = useState<Record<string, string>>({});

  // ✅ 서버에서 내려온 answer key를 최초/재조회 시 반영 (사용자 입력을 덮어쓰지 않도록 단순 merge)
  useEffect(() => {
    const server = akQ.data?.answers;
    if (!server || typeof server !== "object") return;

    setAnswers((prev) => {
      const next: Record<string, string> = { ...prev };
      for (const [k, v] of Object.entries(server)) {
        if (next[k] == null || String(next[k]).length === 0) {
          next[String(k)] = String(v);
        }
      }
      return next;
    });
  }, [akQ.data?.id]);

  const [omrQuestionCount, setOmrQuestionCount] = useState<(typeof QUESTION_COUNTS)[number]>(20);

  const scoreMut = useMutation({
    mutationFn: patchSheetQuestionScoreApi,
    onSuccess: () => qc.invalidateQueries({ queryKey: ["materials-sheet-questions", id] }),
    onError: (e: any) => alert(e?.message || "배점 저장 실패"),
  });

  const answerKeyMut = useMutation({
    mutationFn: upsertSheetAnswerKeyApi,
    onSuccess: () => qc.invalidateQueries({ queryKey: ["materials-sheet-answerkey", id] }),
    onError: (e: any) => alert(e?.message || "정답 저장 실패"),
  });

  const autoGenMut = useMutation({
    mutationFn: autoGenerateQuestionsApi,
    onSuccess: () => qc.invalidateQueries({ queryKey: ["materials-sheet-questions", id] }),
    onError: (e: any) => alert(e?.message || "문항 자동 복구 실패"),
  });

  const genOmrMut = useMutation({
    mutationFn: generateOmrSheetAssetApi,
    onSuccess: () => qc.invalidateQueries({ queryKey: ["materials-sheet-assets", id] }),
    onError: (e: any) => alert(e?.message || "OMR 생성 실패"),
  });

  if (id <= 0) {
    return <EmptyState title="잘못된 접근" message="유효하지 않은 시험지입니다." />;
  }

  if (sheetQ.isLoading || qQ.isLoading) {
    return <div className="p-4 text-sm">불러오는 중...</div>;
  }

  if (sheetQ.isError || qQ.isError) {
    return (
      <div className="p-4">
        <EmptyState title="불러오기 실패" message="시험지 정보를 불러오지 못했습니다." />
      </div>
    );
  }

  const assets = assetsQ.data ?? [];
  const omr = assets.find((a) => a.asset_type === "omr_sheet");
  const problem = assets.find((a) => a.asset_type === "problem_pdf");

  return (
    <div className="p-6 space-y-6">
      {/* TOP HEADER */}
      <div className="flex items-start justify-between gap-6">
        <div>
          <div className="text-lg font-bold">{sheetQ.data?.title}</div>
          <div className="text-xs text-gray-500">과목: {sheetQ.data?.subject}</div>
        </div>

        <div className="flex items-center gap-3">
          <div className="flex items-center gap-2">
            <span className="text-xs text-gray-500">OMR 문항수</span>
            <div className="flex gap-2">
              {QUESTION_COUNTS.map((qc2) => (
                <button
                  key={qc2}
                  type="button"
                  className={`btn ${omrQuestionCount === qc2 ? "bg-black text-white" : ""}`}
                  onClick={() => setOmrQuestionCount(qc2)}
                >
                  {qc2}
                </button>
              ))}
            </div>
          </div>

          <button
            className="btn"
            disabled={autoGenMut.isPending}
            onClick={() =>
              autoGenMut.mutate({
                templateExamId: id,
                questionCount: omrQuestionCount,
              })
            }
          >
            {autoGenMut.isPending ? "복구 중..." : "문항 자동 복구"}
          </button>

          <button
            className="btn-primary"
            disabled={genOmrMut.isPending}
            onClick={() =>
              genOmrMut.mutate({
                templateExamId: id,
                questionCount: omrQuestionCount,
              })
            }
          >
            {genOmrMut.isPending ? "생성 중..." : "OMR 생성"}
          </button>
        </div>
      </div>

      {/* LOCAL TABS */}
      <div className="flex items-center gap-2 border-b pb-2">
        <button
          type="button"
          className={`btn ${tab === "editor" ? "bg-black text-white" : ""}`}
          onClick={() => setTab("editor")}
        >
          편집
        </button>
        <button
          type="button"
          className={`btn ${tab === "submissions" ? "bg-black text-white" : ""}`}
          onClick={() => setTab("submissions")}
        >
          제출
        </button>
      </div>

      {/* TAB: SUBMISSIONS */}
      {tab === "submissions" && (
        <div className="surface p-4 rounded-xl border">
          <SheetsSubmissionsTab
            examId={id}
            sheetTitle={String(sheetQ.data?.title || "")}
            questions={questions}
          />
        </div>
      )}

      {/* TAB: EDITOR */}
      {tab === "editor" && (
        <div className="space-y-8">
          {/* QUESTIONS */}
          <div className="space-y-3">
            <div className="text-sm font-semibold">문항 / 배점 / 정답</div>

            {questions.length === 0 && (
              <div className="text-xs text-gray-500">
                문항이 없습니다. 상단의 “문항 자동 복구”로 question ROI 기반 문항을 생성하세요.
              </div>
            )}

            {questions.map((q: SheetQuestionEntity) => {
              const key = String(q.id);
              return (
                <div key={q.id} className="flex items-center gap-3 border rounded px-3 py-2">
                  <div className="w-12 text-sm font-semibold">#{q.number}</div>

                  <input
                    type="number"
                    className="w-20 input"
                    defaultValue={q.score}
                    onBlur={(e) =>
                      scoreMut.mutate({
                        questionId: q.id,
                        score: Number(e.target.value),
                      })
                    }
                  />

                  <div className="flex gap-1">
                    {CHOICES.map((c) => (
                      <button
                        key={c}
                        type="button"
                        className={`px-2 py-1 border rounded ${answers[key] === c ? "bg-black text-white" : ""}`}
                        onClick={() => setAnswers((prev) => ({ ...prev, [key]: c }))}
                      >
                        {c}
                      </button>
                    ))}
                  </div>
                </div>
              );
            })}
          </div>

          {/* ANSWER KEY */}
          <div className="flex justify-end">
            <button
              className="btn-primary"
              disabled={answerKeyMut.isPending}
              onClick={() =>
                answerKeyMut.mutate({
                  sheetId: id, // historical name: 실제로는 examId
                  existingId: akQ.data?.id,
                  answers,
                })
              }
            >
              {answerKeyMut.isPending ? "저장 중..." : "정답 저장"}
            </button>
          </div>

          {/* ASSETS */}
          <div className="space-y-2">
            <div className="text-sm font-semibold">생성된 자산</div>

            {assetsQ.isLoading && <div className="text-xs text-gray-500">불러오는 중...</div>}

            {!assetsQ.isLoading && assets.length === 0 && (
              <div className="text-xs text-gray-500">아직 생성된 자산이 없습니다.</div>
            )}

            {omr?.download_url && (
              <div className="text-xs">
                <span className="text-gray-600">OMR:</span>{" "}
                <a className="underline" href={omr.download_url} target="_blank" rel="noreferrer">
                  다운로드
                </a>
              </div>
            )}

            {problem?.download_url && (
              <div className="text-xs">
                <span className="text-gray-600">문제 PDF:</span>{" "}
                <a className="underline" href={problem.download_url} target="_blank" rel="noreferrer">
                  다운로드
                </a>
              </div>
            )}

            {assets.map((a) => (
              <div key={a.id} className="text-xs">
                {a.asset_type} — {a.file_key}
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}


==========================================================================================
# FILE: sheets/components/editor/SheetsEditorModal.tsx
==========================================================================================
// ======================================================================================
// FILE: src/features/materials/sheets/components/editor/SheetsEditorModal.tsx
// ======================================================================================
import { createPortal } from "react-dom";
import { Button } from "@/shared/ui/ds";
import SheetsEditorBody from "./SheetsEditorBody";

export function SheetsEditorModal({
  open,
  sheetId,
  onClose,
}: {
  open: boolean;
  sheetId: number;
  onClose: () => void;
}) {
  if (!open) return null;

  return createPortal(
    <div
      className="fixed inset-0 z-[70] bg-black/60 backdrop-blur-[1px]"
      onMouseDown={(e) => {
        if (e.target === e.currentTarget) onClose();
      }}
    >
      <div className="absolute inset-4 lg:inset-8 bg-[var(--bg-page)] rounded-2xl overflow-hidden flex flex-col border shadow-2xl">
        <div className="px-4 py-3 border-b bg-[var(--bg-surface)] flex items-center justify-between">
          <div className="text-sm font-extrabold">시험지 상품 제작실</div>
          <Button type="button" intent="ghost" size="sm" onClick={onClose}>
            닫기
          </Button>
        </div>
        <div className="flex-1 overflow-auto">
          <SheetsEditorBody sheetId={sheetId} />
        </div>
      </div>
    </div>,
    document.body
  );
}


==========================================================================================
# FILE: sheets/components/submissions/SheetsSubmissionsTab.tsx
==========================================================================================
// PATH: src/features/materials/sheets/components/submissions/SheetsSubmissionsTab.tsx
// SSOT ALIGN (domains/submissions):
// - list: GET /submissions/exams/<exam_id>/
// - 운영자 수동 개입: manual-edit / retry

import { useMemo, useState } from "react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { Button, EmptyState } from "@/shared/ui/ds";
import type { SheetQuestionEntity } from "../../sheets.api";
import {
  listExamSubmissionsApi,
  retrySubmissionApi,
  uploadOmrBatchApi,
  type ExamSubmissionRow,
} from "./submissions.api";
import SubmissionRow from "./SubmissionRow";
import SubmissionManualEditModal from "./SubmissionManualEditModal";

type Props = {
  examId: number;
  sheetTitle?: string;
  questions: SheetQuestionEntity[];
};

type StatusFilter = "all" | "pending" | "processing" | "done" | "failed";

export default function SheetsSubmissionsTab({ examId, sheetTitle, questions }: Props) {
  const qc = useQueryClient();

  const [filter, setFilter] = useState<StatusFilter>("all");
  const [selectedId, setSelectedId] = useState<number | null>(null);

  // batch upload
  const [batchFiles, setBatchFiles] = useState<File[]>([]);
  const [batchSheetId, setBatchSheetId] = useState<string>("");

  const listQ = useQuery({
    queryKey: ["materials-submissions", examId],
    queryFn: () => listExamSubmissionsApi(examId),
    enabled: examId > 0,
    refetchInterval: 10_000, // 운영 화면: 자동 갱신
  });

  const retryMut = useMutation({
    mutationFn: (submissionId: number) => retrySubmissionApi(submissionId),
    onSuccess: () => qc.invalidateQueries({ queryKey: ["materials-submissions", examId] }),
    onError: (e: any) => alert(e?.message || "재시도 실패"),
  });

  const batchMut = useMutation({
    mutationFn: async () => {
      const files = batchFiles ?? [];
      return await uploadOmrBatchApi({
        examId,
        files,
        sheetId: batchSheetId.trim() ? batchSheetId.trim() : null,
      });
    },
    onSuccess: () => {
      setBatchFiles([]);
      setBatchSheetId("");
      qc.invalidateQueries({ queryKey: ["materials-submissions", examId] });
      alert("업로드 요청이 접수되었습니다. 처리 상태는 목록에서 확인하세요.");
    },
    onError: (e: any) => alert(e?.message || "다건 업로드 실패"),
  });

  const items: ExamSubmissionRow[] = useMemo(() => {
    const rows = listQ.data ?? [];
    if (filter === "all") return rows;
    return rows.filter((r) => r.status === filter);
  }, [listQ.data, filter]);

  return (
    <div className="space-y-4">
      {/* Header */}
      <div className="flex items-start justify-between gap-4">
        <div>
          <div className="text-sm font-semibold">제출</div>
          <div className="text-xs text-gray-600 mt-1">
            시험: <span className="font-medium">{sheetTitle || `#${examId}`}</span> (exam_id: {examId})
          </div>
        </div>

        <div className="flex items-center gap-2">
          <Button type="button" intent="secondary" size="sm" onClick={() => listQ.refetch()} disabled={listQ.isFetching}>
            {listQ.isFetching ? "갱신 중..." : "새로고침"}
          </Button>

          <select className="input" value={filter} onChange={(e) => setFilter(e.target.value as StatusFilter)}>
            <option value="all">전체</option>
            <option value="pending">대기(pending)</option>
            <option value="processing">처리중(processing)</option>
            <option value="done">완료(done)</option>
            <option value="failed">실패(failed)</option>
          </select>
        </div>
      </div>

      {/* Batch upload panel */}
      <div className="rounded-xl border bg-[var(--bg-surface-soft)] p-4 space-y-3">
        <div className="text-sm font-semibold">OMR 다건 업로드</div>
        <div className="text-xs text-gray-600">
          백엔드 SSOT: <code>/submissions/exams/&lt;exam_id&gt;/omr/batch/</code>
          <br />
          (선택) sheet_id를 함께 보내면 AI 워커가 문항 ROI를 더 안정적으로 사용합니다.
        </div>

        <div className="flex flex-wrap items-center gap-3">
          <input
            className="input w-40"
            placeholder="(선택) sheet_id"
            value={batchSheetId}
            onChange={(e) => setBatchSheetId(e.target.value)}
          />

          <input
            type="file"
            multiple
            accept="image/*,application/pdf"
            onChange={(e) => setBatchFiles(Array.from(e.target.files ?? []))}
          />

          <Button
            type="button"
            intent="primary"
            size="md"
            disabled={batchMut.isPending || (batchFiles?.length ?? 0) === 0}
            onClick={() => batchMut.mutate()}
          >
            {batchMut.isPending ? "업로드 중..." : `업로드 (${batchFiles.length})`}
          </Button>

          {(batchFiles?.length ?? 0) > 0 && (
            <Button type="button" intent="secondary" size="md" onClick={() => setBatchFiles([])} disabled={batchMut.isPending}>
              선택 해제
            </Button>
          )}
        </div>

        {(batchFiles?.length ?? 0) > 0 && (
          <div className="text-xs text-gray-600">
            선택된 파일: {batchFiles.map((f) => f.name).join(", ")}
          </div>
        )}
      </div>

      {/* List */}
      <div className="surface p-0 rounded-xl border overflow-hidden">
        {listQ.isLoading && <div className="p-4 text-sm">불러오는 중...</div>}

        {!listQ.isLoading && items.length === 0 && (
          <div className="p-4">
            <EmptyState title="제출이 없습니다" message="아직 제출된 OMR이 없습니다." />
          </div>
        )}

        {items.length > 0 && (
          <table className="table">
            <thead>
              <tr>
                <th>ID</th>
                <th>학생</th>
                <th>상태</th>
                <th>점수</th>
                <th>제출시각</th>
                <th className="text-right">작업</th>
              </tr>
            </thead>
            <tbody>
              {items.map((row) => (
                <SubmissionRow
                  key={row.id}
                  row={row}
                  onManualEdit={() => setSelectedId(row.id)}
                  onRetry={() => retryMut.mutate(row.id)}
                  retryLoading={retryMut.isPending}
                />
              ))}
            </tbody>
          </table>
        )}
      </div>

      {/* Manual edit modal */}
      {selectedId && (
        <SubmissionManualEditModal
          open
          onClose={() => setSelectedId(null)}
          examId={examId}
          submissionId={selectedId}
          questions={questions}
          onDone={() => {
            qc.invalidateQueries({ queryKey: ["materials-submissions", examId] });
            setSelectedId(null);
          }}
        />
      )}
    </div>
  );
}


==========================================================================================
# FILE: sheets/components/submissions/SubmissionManualEditModal.tsx
==========================================================================================
// PATH: src/features/materials/sheets/components/submissions/SubmissionManualEditModal.tsx
// SSOT ALIGN (domains/submissions):
// - manual-edit: POST /submissions/submissions/<submission_id>/manual-edit/
//   payload:
//     {
//       identifier: any,
//       answers: [{ exam_question_id, answer }],
//       note: string
//     }
//
// NOTE (중요):
// - 현재 백엔드에는 "submission answers 조회" 전용 endpoint가 제공되지 않는다.
// - 따라서 이 모달은 운영자가 "필요한 문항만" 직접 입력하여 보정하는 방식으로 설계한다.
// - 입력이 비어있는 문항은 서버에 보내지지 않는다(불필요 update 방지).

import { useMemo, useState } from "react";
import { createPortal } from "react-dom";
import { useMutation } from "@tanstack/react-query";
import { Button } from "@/shared/ui/ds";
import type { SheetQuestionEntity } from "../../sheets.api";
import { manualEditSubmissionApi } from "./submissions.api";

export default function SubmissionManualEditModal({
  open,
  onClose,
  examId,
  submissionId,
  questions,
  onDone,
}: {
  open: boolean;
  onClose: () => void;
  examId: number;
  submissionId: number;
  questions: SheetQuestionEntity[];
  onDone: () => void;
}) {
  const sorted = useMemo(() => (questions ?? []).slice().sort((a, b) => a.number - b.number), [questions]);

  // identifier override: enrollment_id 등 (백엔드에서 그대로 meta에 저장)
  const [identifierEnrollmentId, setIdentifierEnrollmentId] = useState<string>("");
  const [note, setNote] = useState<string>("manual_edit");

  // answers: key=exam_question_id(string)
  const [localAnswers, setLocalAnswers] = useState<Record<string, string>>({});

  const mut = useMutation({
    mutationFn: async () => {
      const answers = Object.entries(localAnswers)
        .map(([k, v]) => ({
          exam_question_id: Number(k),
          answer: String(v ?? ""),
        }))
        .filter((a) => Number.isFinite(a.exam_question_id) && a.exam_question_id > 0)
        // 비어있는 답은 보내지지 않게 (운영 실수 방지)
        .filter((a) => String(a.answer).trim().length > 0);

      const identifier =
        identifierEnrollmentId.trim().length > 0
          ? { enrollment_id: Number(identifierEnrollmentId.trim()) || identifierEnrollmentId.trim() }
          : null;

      return await manualEditSubmissionApi({
        submissionId,
        identifier,
        note: note.trim() || "manual_edit",
        answers,
      });
    },
    onSuccess: () => {
      alert("수동 수정이 반영되었습니다. 채점이 재시도되었을 수 있습니다(서버 로직).");
      onDone();
    },
    onError: (e: any) => alert(e?.message || "수동 수정 실패"),
  });

  if (!open) return null;

  return createPortal(
    <div
      className="fixed inset-0 z-[90] bg-black/60 backdrop-blur-[1px] flex items-center justify-center p-4"
      onMouseDown={(e) => {
        if (e.target === e.currentTarget) onClose();
      }}
    >
      <div className="w-full max-w-5xl rounded-2xl bg-[var(--bg-page)] shadow-2xl overflow-hidden border">
        <div className="px-6 py-4 border-b bg-[var(--bg-surface)] flex items-center justify-between">
          <div>
            <div className="text-base font-extrabold">제출 수동 수정</div>
            <div className="text-xs text-[var(--text-muted)] mt-1">
              exam_id: {examId} · submission_id: {submissionId}
            </div>
          </div>

          <Button type="button" intent="ghost" size="sm" onClick={onClose} disabled={mut.isPending}>
            닫기
          </Button>
        </div>

        <div className="p-6 space-y-6">
          <div className="rounded-xl border bg-[var(--bg-surface-soft)] p-4 space-y-3">
            <div className="text-sm font-semibold">식별자(선택)</div>
            <div className="text-xs text-gray-600">
              enrollment_id 식별이 실패한 경우(backend: needs_identification) 운영자가 강제로 지정할 수 있습니다.
              <br />
              이 값은 submission.meta에 override로 저장됩니다(백엔드 로직).
            </div>

            <div className="flex flex-wrap items-center gap-3">
              <input
                className="input w-56"
                placeholder="enrollment_id (숫자)"
                value={identifierEnrollmentId}
                onChange={(e) => setIdentifierEnrollmentId(e.target.value)}
              />

              <input
                className="input flex-1 min-w-[240px]"
                placeholder="note (예: 조교 수동 보정)"
                value={note}
                onChange={(e) => setNote(e.target.value)}
                maxLength={120}
              />
            </div>
          </div>

          <div>
            <div className="text-sm font-semibold">답안 입력</div>
            <div className="text-xs text-gray-600 mt-1">
              필요한 문항만 입력하세요. 비어있는 항목은 서버로 전송되지 않습니다.
              <br />
              exam_question_id 기준(단일진실)으로 저장됩니다.
            </div>

            <div className="mt-3 rounded-xl border overflow-hidden">
              <table className="table">
                <thead>
                  <tr>
                    <th className="w-24">번호</th>
                    <th>exam_question_id</th>
                    <th className="w-64">답안</th>
                    <th className="w-28 text-right">작업</th>
                  </tr>
                </thead>
                <tbody>
                  {sorted.map((q) => {
                    const key = String(q.id);
                    return (
                      <tr key={q.id}>
                        <td>#{q.number}</td>
                        <td className="text-xs text-gray-600">{q.id}</td>
                        <td>
                          <input
                            className="input w-full"
                            placeholder="예: A 또는 3 또는 주관식 텍스트"
                            value={localAnswers[key] ?? ""}
                            onChange={(e) =>
                              setLocalAnswers((prev) => ({
                                ...prev,
                                [key]: e.target.value,
                              }))
                            }
                          />
                        </td>
                        <td className="text-right">
                          <Button
                            type="button"
                            intent="ghost"
                            size="sm"
                            onClick={() =>
                              setLocalAnswers((prev) => {
                                const next = { ...prev };
                                delete next[key];
                                return next;
                              })
                            }
                          >
                            지우기
                          </Button>
                        </td>
                      </tr>
                    );
                  })}

                  {sorted.length === 0 && (
                    <tr>
                      <td colSpan={4}>
                        <div className="p-4 text-xs text-gray-600">
                          문항이 없습니다. 먼저 “문항 자동 복구”로 문항을 생성하세요.
                        </div>
                      </td>
                    </tr>
                  )}
                </tbody>
              </table>
            </div>
          </div>

          <div className="flex items-center justify-end gap-2">
            <Button type="button" intent="secondary" size="md" onClick={onClose} disabled={mut.isPending}>
              취소
            </Button>
            <Button
              type="button"
              intent="primary"
              size="md"
              disabled={mut.isPending}
              onClick={() => mut.mutate()}
            >
              {mut.isPending ? "저장 중..." : "저장 및 채점 재개"}
            </Button>
          </div>

          <div className="text-[11px] text-gray-600">
            ⚠️ 수동 수정은 운영 권한이 필요한 작업입니다. 서버 정책(채점/결과 도메인)에 따라 즉시 채점이 재개될 수 있습니다.
          </div>
        </div>
      </div>
    </div>,
    document.body
  );
}


==========================================================================================
# FILE: sheets/components/submissions/SubmissionRow.tsx
==========================================================================================
// PATH: src/features/materials/sheets/components/submissions/SubmissionRow.tsx

import { Button } from "@/shared/ui/ds";
import { SUBMISSION_STATUS_LABEL, SUBMISSION_STATUS_COLOR } from "@/features/submissions/statusMaps";
import type { ExamSubmissionRow } from "./submissions.api";

const STATUS_COLOR_CLASS: Record<string, string> = {
  gray: "text-gray-600",
  blue: "text-blue-700",
  indigo: "text-indigo-700",
  yellow: "text-yellow-700",
  green: "text-green-700",
  red: "text-red-700",
};

export default function SubmissionRow({
  row,
  onManualEdit,
  onRetry,
  retryLoading,
}: {
  row: ExamSubmissionRow;
  onManualEdit: () => void;
  onRetry: () => void;
  retryLoading?: boolean;
}) {
  const statusLabel = SUBMISSION_STATUS_LABEL[row.status as keyof typeof SUBMISSION_STATUS_LABEL] ?? row.status;
  const colorKey = SUBMISSION_STATUS_COLOR[row.status as keyof typeof SUBMISSION_STATUS_COLOR] ?? "gray";
  const statusClass = STATUS_COLOR_CLASS[colorKey] ?? "text-gray-600";

  const student = row.student_name?.trim()
    ? row.student_name.trim()
    : row.enrollment_id
      ? `#${row.enrollment_id}`
      : "-";

  return (
    <tr>
      <td>#{row.id}</td>
      <td>{student}</td>
      <td className={statusClass}>{statusLabel}</td>
      <td>{row.score == null ? "-" : row.score}</td>
      <td className="text-xs text-gray-600">{row.created_at}</td>
      <td className="text-right">
        <div className="flex justify-end gap-2">
          <Button type="button" intent="secondary" size="sm" onClick={onManualEdit}>
            수동 수정
          </Button>

          {(row.status === "failed" || row.status === "needs_identification") && (
            <Button type="button" intent="secondary" size="sm" onClick={onRetry} disabled={!!retryLoading}>
              {retryLoading ? "재시도..." : "재시도"}
            </Button>
          )}
        </div>
      </td>
    </tr>
  );
}


==========================================================================================
# FILE: sheets/components/submissions/submissions.api.ts
==========================================================================================
// PATH: src/features/materials/sheets/components/submissions/submissions.api.ts
// SSOT ALIGN (backend domains/submissions):
// - list:    GET  /submissions/exams/<exam_id>/
// - retry:   POST /submissions/submissions/<submission_id>/retry/
// - manual:  POST /submissions/submissions/<submission_id>/manual-edit/
// - batch:   POST /submissions/exams/<exam_id>/omr/batch/  (multipart, files[])

import api from "@/shared/api/axios";
import type { SubmissionStatus } from "@/features/submissions/types";

/** 백엔드가 구형 pending/processing 반환 시 대비 */
export type ExamSubmissionRow = {
  id: number;
  enrollment_id: number;
  student_name: string;
  status: SubmissionStatus | "pending" | "processing";
  score: number | null;
  created_at: string;
};

export type SubmissionManualEditInput = {
  submissionId: number;
  identifier?: any;
  note?: string;
  answers: Array<{
    exam_question_id: number;
    answer: string;
  }>;
};

export async function listExamSubmissionsApi(examId: number): Promise<ExamSubmissionRow[]> {
  if (!Number.isFinite(examId) || examId <= 0) return [];
  const res = await api.get(`/submissions/exams/${examId}/`);
  const data = res.data;
  if (Array.isArray(data)) return data as ExamSubmissionRow[];
  if (Array.isArray(data?.items)) return data.items as ExamSubmissionRow[];
  if (Array.isArray(data?.results)) return data.results as ExamSubmissionRow[];
  return [];
}

export async function retrySubmissionApi(submissionId: number) {
  if (!Number.isFinite(submissionId) || submissionId <= 0) {
    throw new Error("유효하지 않은 submissionId");
  }
  // router: /submissions/submissions/<pk>/retry/
  const res = await api.post(`/submissions/submissions/${submissionId}/retry/`, {});
  return res.data;
}

export async function manualEditSubmissionApi(input: SubmissionManualEditInput) {
  const sid = Number(input.submissionId);
  if (!Number.isFinite(sid) || sid <= 0) {
    throw new Error("유효하지 않은 submissionId");
  }

  const answers = (input.answers ?? [])
    .filter((a) => a && Number.isFinite(Number(a.exam_question_id)) && String(a.answer ?? "").length >= 0)
    .map((a) => ({
      exam_question_id: Number(a.exam_question_id),
      answer: String(a.answer ?? ""),
    }));

  const payload: any = {
    identifier: input.identifier,
    answers,
    note: String(input.note || "manual_edit"),
  };

  // router: /submissions/submissions/<pk>/manual-edit/
  const res = await api.post(`/submissions/submissions/${sid}/manual-edit/`, payload);
  return res.data;
}

export async function uploadOmrBatchApi(input: { examId: number; files: File[]; sheetId?: number | string | null }) {
  const examId = Number(input.examId);
  if (!Number.isFinite(examId) || examId <= 0) throw new Error("유효하지 않은 examId");

  const files = input.files ?? [];
  if (!Array.isArray(files) || files.length === 0) throw new Error("files required");

  const fd = new FormData();
  for (const f of files) fd.append("files", f);
  if (input.sheetId != null && String(input.sheetId).length > 0) {
    fd.append("sheet_id", String(input.sheetId));
  }

  // urls.py: /submissions/exams/<exam_id>/omr/batch/
  const res = await api.post(`/submissions/exams/${examId}/omr/batch/`, fd, {
    headers: { "Content-Type": "multipart/form-data" },
  });

  return res.data;
}
