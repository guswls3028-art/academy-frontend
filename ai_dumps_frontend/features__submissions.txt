====================================================================================================
# FRONTEND FOLDER: features__submissions
# ROOT PATH: C:\academyfront\src\features\submissions
====================================================================================================


==========================================================================================
# FILE: api.ts
==========================================================================================
// src/features/submissions/api.ts
// --------------------------------------------------
// Submission API (공통 엔드포인트)
// --------------------------------------------------
//
// ✔ 시험 / 과제 / 영상 업로드 전부 여기로
// ✔ 프론트는 R2 / Worker / AI를 절대 알 필요 없음
//

import api from "@/shared/api/axios";
import { Submission } from "./types";

/**
 * ✅ 제출 생성 (파일 업로드)
 *
 * formData 필수 필드 (backend contract):
 * - kind
 * - target_type (exam | homework | video)
 * - target_id
 * - file
 */
export async function createSubmission(formData: FormData) {
  const res = await api.post<Submission>(
    "/submissions/",
    formData,
    {
      headers: {
        "Content-Type": "multipart/form-data",
      },
    }
  );

  return res.data;
}

/**
 * ✅ 제출 상태 단건 조회 (Polling)
 */
export async function fetchSubmission(submissionId: number) {
  const res = await api.get<Submission>(
    `/submissions/${submissionId}/`
  );
  return res.data;
}

/**
 * ✅ 제출 재처리 (FAILED 상태 전용)
 * - 관리자 액션
 */
export async function retrySubmission(submissionId: number) {
  const res = await api.post(
    `/submissions/${submissionId}/retry/`
  );
  return res.data;
}


==========================================================================================
# FILE: statusMaps.ts
==========================================================================================
// PATH: src/features/submissions/statusMaps.ts
import type { SubmissionStatus } from "./types";

export const SUBMISSION_STATUS_LABEL: Record<SubmissionStatus | "graded", string> = {
  submitted: "업로드됨",
  dispatched: "작업 큐 등록",
  extracting: "인식 중",
  needs_identification: "식별 필요", // ✅ 추가
  answers_ready: "답안 생성됨",
  grading: "채점 중",
  done: "완료",
  failed: "실패",
  graded: "채점 완료",
};

export const SUBMISSION_STATUS_COLOR: Record<SubmissionStatus | "graded", string> = {
  submitted: "gray",
  dispatched: "blue",
  extracting: "indigo",
  needs_identification: "yellow", // ✅ 추가(주의)
  answers_ready: "yellow",
  grading: "yellow",
  done: "green",
  failed: "red",
  graded: "green",
};


==========================================================================================
# FILE: types.ts
==========================================================================================
// PATH: src/features/submissions/types.ts

export type SubmissionStatus =
  | "submitted"
  | "dispatched"
  | "extracting"
  | "needs_identification" // ✅ 추가
  | "answers_ready"
  | "grading"
  | "done"
  | "failed";

export type SubmissionSource =
  | "omr_scan"
  | "omr_manual"
  | "online"
  | "homework_image"
  | "homework_video"
  | "ai_match";

export type SubmissionTargetType = "exam" | "homework";

/**
 * ✅ Backend Submission 모델과 1:1 대응
 */
export type Submission = {
  id: number;

  enrollment_id: number | null;

  target_type: SubmissionTargetType;
  target_id: number;

  source: SubmissionSource;
  status: SubmissionStatus;

  file_key?: string | null;
  file_type?: string | null;
  file_size?: number | null;

  payload?: any;
  meta?: any;
  error_message?: string;

  created_at: string;
  updated_at: string;
};


==========================================================================================
# FILE: api/adminOmrUpload.ts
==========================================================================================
// PATH: src/features/submissions/api/adminOmrUpload.ts

import api from "@/shared/api/axios";
// ✅ [수정] SubmissionStatus는 submissions 도메인 타입을 사용해야 함
// (기존) import type { SubmissionStatus } from "@/features/exams/types";
import type { SubmissionStatus } from "@/features/submissions/types";

// ✅ 너의 현재 백엔드 라우터 기준(기본값)
// - 만약 서버를 정리해서 /submissions/... 로 만들면 아래만 바꾸면 됨.
const SUBMISSIONS_BASE = "/submissions/submissions";

export interface AdminOmrUploadResponse {
  submission_id: number;
  status: SubmissionStatus;
}

/**
 * POST /api/v1/submissions/submissions/admin/omr-upload/
 * form-data: enrollment_id, target_id(exam_id), file
 */
export async function adminOmrUpload(params: {
  examId: number;
  enrollmentId: number;
  file: File;
}): Promise<AdminOmrUploadResponse> {
  const fd = new FormData();
  fd.append("enrollment_id", String(params.enrollmentId));
  fd.append("target_id", String(params.examId));
  fd.append("file", params.file);

  const res = await api.post(`${SUBMISSIONS_BASE}/admin/omr-upload/`, fd, {
    headers: { "Content-Type": "multipart/form-data" },
  });

  return res.data;
}

/**
 * POST /api/v1/submissions/submissions/{id}/retry/
 */
export async function retrySubmission(submissionId: number): Promise<{
  submission_id: number;
  status: SubmissionStatus;
}> {
  const res = await api.post(`${SUBMISSIONS_BASE}/${submissionId}/retry/`);
  return res.data;
}


==========================================================================================
# FILE: api/adminSubmissions.ts
==========================================================================================
// PATH: src/features/submissions/api/adminSubmissions.ts
import api from "@/shared/api/axios";
import type { Submission, SubmissionStatus } from "@/features/submissions/types";

const CANDIDATE_BASES = ["/submissions", "/submissions/submissions"] as const;

async function tryGet<T>(paths: string[], params?: any): Promise<T> {
  let lastErr: any = null;
  for (const p of paths) {
    try {
      const res = await api.get(p, { params });
      return res.data as T;
    } catch (e: any) {
      lastErr = e;
    }
  }
  throw lastErr;
}

async function tryPost<T>(paths: string[], body?: any): Promise<T> {
  let lastErr: any = null;
  for (const p of paths) {
    try {
      const res = await api.post(p, body ?? {});
      return res.data as T;
    } catch (e: any) {
      lastErr = e;
    }
  }
  throw lastErr;
}

/**
 * ✅ Admin submission list (best-effort)
 * - filters: exam_id(target_id), enrollment_id, status
 * - supports DRF pagination or plain array
 */
export async function fetchAdminSubmissions(params?: {
  examId?: number;
  enrollmentId?: number;
  status?: SubmissionStatus;
  limit?: number;
}): Promise<Submission[]> {
  const query: any = {};
  if (Number.isFinite(params?.examId)) {
    query.target_type = "exam";
    query.target_id = params!.examId;
  }
  if (Number.isFinite(params?.enrollmentId)) query.enrollment_id = params!.enrollmentId;
  if (params?.status) query.status = params.status;
  if (Number.isFinite(params?.limit)) query.limit = params!.limit;

  const paths: string[] = [];
  for (const b of CANDIDATE_BASES) {
    paths.push(`${b}/admin/submissions/`);
    paths.push(`${b}/submissions/`);
    paths.push(`${b}/`);
  }

  const data = await tryGet<any>(paths, query);

  if (Array.isArray(data)) return data as Submission[];
  if (Array.isArray(data?.results)) return data.results as Submission[];
  if (Array.isArray(data?.items)) return data.items as Submission[];
  return [];
}

/**
 * ✅ Unified retry (FAILED only)
 * - tries both public and admin base paths
 */
export async function retryAnySubmission(submissionId: number): Promise<{
  submission_id?: number;
  id?: number;
  status?: SubmissionStatus;
} | any> {
  const paths: string[] = [];
  for (const b of CANDIDATE_BASES) {
    paths.push(`${b}/${submissionId}/retry/`);
    paths.push(`${b}/submissions/${submissionId}/retry/`);
  }
  return tryPost<any>(paths, {});
}

/**
 * ✅ Manual review fetch (best-effort)
 * - expects shape:
 *   {
 *     identifier?: string | null,
 *     answers?: Array<{ question_id?: number; question_no?: number; answer?: string; meta?: any }>,
 *     meta?: any
 *   }
 */
export async function fetchSubmissionManualReview(submissionId: number): Promise<{
  identifier?: string | null;
  answers?: Array<{
    question_id?: number;
    question_no?: number;
    answer?: string;
    meta?: any;
  }>;
  meta?: any;
}> {
  const paths: string[] = [];
  for (const b of CANDIDATE_BASES) {
    paths.push(`${b}/${submissionId}/manual-review/`);
    paths.push(`${b}/${submissionId}/manual_edit/`);
    paths.push(`${b}/${submissionId}/manual-edit/`);
    paths.push(`${b}/submissions/${submissionId}/manual-review/`);
    paths.push(`${b}/submissions/${submissionId}/manual_edit/`);
    paths.push(`${b}/submissions/${submissionId}/manual-edit/`);
  }
  return tryGet<any>(paths);
}

/**
 * ✅ Manual review save + regrade (best-effort)
 * - payload contract is intentionally minimal and append-only friendly:
 *   {
 *     identifier?: string | null,
 *     answers?: Array<{ question_id?: number; question_no?: number; answer: string }>
 *   }
 */
export async function saveSubmissionManualReview(submissionId: number, payload: {
  identifier?: string | null;
  answers: Array<{ question_id?: number; question_no?: number; answer: string }>;
}): Promise<any> {
  const paths: string[] = [];
  for (const b of CANDIDATE_BASES) {
    paths.push(`${b}/${submissionId}/manual-review/`);
    paths.push(`${b}/${submissionId}/manual_edit/`);
    paths.push(`${b}/${submissionId}/manual-edit/`);
    paths.push(`${b}/submissions/${submissionId}/manual-review/`);
    paths.push(`${b}/submissions/${submissionId}/manual_edit/`);
    paths.push(`${b}/submissions/${submissionId}/manual-edit/`);
  }
  return tryPost<any>(paths, payload);
}


==========================================================================================
# FILE: api/adminSubmissionsApi.ts
==========================================================================================
import api from "@/shared/api/axios";

export type SubmissionRow = {
  id: number;
  enrollment_id: number;
  student_name: string;
  status: "pending" | "processing" | "done" | "failed";
  score: number | null;
  created_at: string;
};

export async function fetchExamSubmissions(examId: number) {
  const res = await api.get(`/submissions/exams/${examId}/`);

  const data = res.data;
  if (Array.isArray(data)) return data as SubmissionRow[];
  if (Array.isArray(data?.results)) return data.results as SubmissionRow[];

  return [];
}


==========================================================================================
# FILE: components/AdminOmrBatchUploadBox.tsx
==========================================================================================
import { useMemo, useRef, useState } from "react";
import api from "@/shared/api/axios";

type Props = {
  examId: number;
};

type UploadItem = {
  file: File;
  status: "ready" | "uploading" | "done" | "fail";
  message?: string;
};

function humanizeBytes(bytes: number) {
  if (!Number.isFinite(bytes) || bytes <= 0) return "-";
  const units = ["B", "KB", "MB", "GB"];
  let v = bytes;
  let i = 0;
  while (v >= 1024 && i < units.length - 1) {
    v /= 1024;
    i += 1;
  }
  return `${v.toFixed(i === 0 ? 0 : 1)} ${units[i]}`;
}

/**
 * AdminOmrBatchUploadBox (Production)
 * - 목적: OMR 다건 업로드 → 서버가 식별/인식/채점 파이프라인 처리
 * - 핵심: "조교가 식별번호 입력" 같은 UX 금지. 파일만 올리면 된다.
 * - 서버 계약: POST /submissions/exams/{examId}/omr/batch/
 *   - 만약 아직 백엔드 미구현이면 404/501 → 안내 표시 후 조용히 중단
 */
export default function AdminOmrBatchUploadBox({ examId }: Props) {
  const inputRef = useRef<HTMLInputElement | null>(null);
  const [items, setItems] = useState<UploadItem[]>([]);
  const [busy, setBusy] = useState(false);
  const [notice, setNotice] = useState<string | null>(null);

  const readyCount = useMemo(() => items.filter((x) => x.status === "ready").length, [items]);
  const doneCount = useMemo(() => items.filter((x) => x.status === "done").length, [items]);
  const failCount = useMemo(() => items.filter((x) => x.status === "fail").length, [items]);

  const onPickFiles = (files: FileList | null) => {
    if (!files || files.length === 0) return;
    setNotice(null);

    const next: UploadItem[] = Array.from(files).map((f) => ({
      file: f,
      status: "ready",
    }));

    setItems((prev) => [...prev, ...next]);

    // 같은 파일 재선택 가능하도록 reset
    if (inputRef.current) inputRef.current.value = "";
  };

  const clear = () => {
    if (busy) return;
    setItems([]);
    setNotice(null);
  };

  const removeOne = (idx: number) => {
    if (busy) return;
    setItems((prev) => prev.filter((_, i) => i !== idx));
  };

  const upload = async () => {
    if (busy) return;
    if (!Number.isFinite(examId) || examId <= 0) {
      setNotice("유효하지 않은 examId 입니다.");
      return;
    }
    if (items.length === 0) {
      setNotice("업로드할 파일이 없습니다.");
      return;
    }

    setBusy(true);
    setNotice(null);

    // 순차 업로드(서버 보호). 필요하면 동시성 N으로 바꿔도 됨.
    for (let i = 0; i < items.length; i++) {
      const it = items[i];
      if (it.status !== "ready") continue;

      setItems((prev) =>
        prev.map((x, idx) => (idx === i ? { ...x, status: "uploading", message: undefined } : x))
      );

      try {
        const fd = new FormData();
        fd.append("files", it.file);

        // ✅ 여기 엔드포인트가 없으면 404가 날 수 있음 → 그 경우 조용히 안내 후 중단
        await api.post(`/submissions/exams/${examId}/omr/batch/`, fd, {
          headers: { "Content-Type": "multipart/form-data" },
        });

        setItems((prev) =>
          prev.map((x, idx) => (idx === i ? { ...x, status: "done", message: "등록됨" } : x))
        );
      } catch (e: any) {
        const status = e?.response?.status;
        const detail = e?.response?.data?.detail;

        // 404/501이면 백엔드 미구현 or 라우팅 불일치 → 무한 시도 금지(즉시 중단)
        if (status === 404 || status === 501) {
          setItems((prev) =>
            prev.map((x, idx) =>
              idx === i ? { ...x, status: "fail", message: "API 미연결(404/501)" } : x
            )
          );
          setNotice(
            "다건 업로드 API가 아직 연결되지 않았습니다(404/501). 백엔드에 batch endpoint를 연결하면 바로 활성화됩니다."
          );
          break;
        }

        setItems((prev) =>
          prev.map((x, idx) =>
            idx === i ? { ...x, status: "fail", message: String(detail || "업로드 실패") } : x
          )
        );
      }
    }

    setBusy(false);
  };

  return (
    <>
      <div className="space-y-3">
        <div className="flex items-start justify-between gap-3">
          <div>
            <div className="text-sm font-semibold text-[var(--text-primary)]">다건 OMR 업로드</div>
            <div className="mt-1 text-xs text-[var(--text-muted)] leading-relaxed">
              여러 장을 한 번에 올리면 서버가 <b>식별 → 답안추출 → 채점</b>을 자동 처리합니다.
              <br />
              (조교가 식별번호를 입력하는 UX는 금지. 파일만 올리면 됩니다)
            </div>
          </div>

          <div className="text-right text-xs text-[var(--text-muted)]">
            <div>
              준비 <b>{readyCount}</b> · 완료 <b>{doneCount}</b> · 실패 <b>{failCount}</b>
            </div>
          </div>
        </div>

        {notice && (
          <div className="rounded border border-yellow-600/30 bg-yellow-600/10 p-3 text-sm text-yellow-800">
            {notice}
          </div>
        )}

        <div className="rounded border border-[var(--border-divider)] bg-[var(--bg-surface)] p-4 space-y-3">
          <div className="flex flex-wrap items-center gap-2">
            <input
              ref={inputRef}
              type="file"
              multiple
              accept="image/*,application/pdf"
              onChange={(e) => onPickFiles(e.target.files)}
              disabled={busy}
              className="text-sm"
            />

            <button className="btn-primary" disabled={busy || items.length === 0} onClick={() => void upload()}>
              {busy ? "업로드 중..." : "업로드 시작"}
            </button>

            <button className="btn" disabled={busy || items.length === 0} onClick={clear}>
              비우기
            </button>
          </div>

          {items.length === 0 ? (
            <div className="text-sm text-[var(--text-muted)]">아직 선택된 파일이 없습니다.</div>
          ) : (
            <div className="rounded border overflow-hidden">
              <table className="table">
                <thead>
                  <tr>
                    <th>파일</th>
                    <th style={{ width: 120 }}>크기</th>
                    <th style={{ width: 140 }}>상태</th>
                    <th style={{ width: 100 }}>삭제</th>
                  </tr>
                </thead>
                <tbody>
                  {items.map((it, idx) => (
                    <tr key={`${it.file.name}-${idx}`}>
                      <td className="text-sm">{it.file.name}</td>
                      <td className="text-sm text-[var(--text-muted)]">{humanizeBytes(it.file.size)}</td>
                      <td className="text-sm">
                        {it.status === "ready" && "대기"}
                        {it.status === "uploading" && "업로드 중..."}
                        {it.status === "done" && <span className="text-emerald-600">완료</span>}
                        {it.status === "fail" && <span className="text-red-600">실패</span>}
                        {it.message ? <span className="ml-2 text-xs text-[var(--text-muted)]">({it.message})</span> : null}
                      </td>
                      <td>
                        <button className="btn" disabled={busy} onClick={() => removeOne(idx)}>
                          삭제
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}

          <div className="text-xs text-[var(--text-muted)]">
            ※ batch API가 없으면 404/501이 뜨며, 그 경우 UI는 자동으로 시도를 멈추고 안내만 표시합니다.
          </div>
        </div>
      </div>
    </>
  );
}


==========================================================================================
# FILE: components/AdminOmrUploadBox.tsx
==========================================================================================
// src/features/submissions/components/AdminOmrUploadBox.tsx
import { useRef, useState } from "react";
import { useMutation } from "@tanstack/react-query";
import { adminOmrUpload } from "@/features/submissions/api/adminOmrUpload";

export default function AdminOmrUploadBox({
  examId,
  onUploaded,
}: {
  examId: number;
  onUploaded?: (submissionId: number) => void;
}) {
  const inputRef = useRef<HTMLInputElement | null>(null);
  const [enrollmentId, setEnrollmentId] = useState<string>("");

  const uploadMut = useMutation({
    mutationFn: async (file: File) => {
      return adminOmrUpload({
        examId,
        enrollmentId: Number(enrollmentId || 0),
        file,
      });
    },
    onSuccess: (data) => {
      onUploaded?.(data.submission_id);
    },
  });

  return (
    <div className="rounded-xl border border-neutral-800 bg-neutral-950 p-4">
      <div className="text-sm font-semibold text-neutral-100 mb-1">
        OMR 답안 업로드
      </div>
      <div className="text-xs text-neutral-400 mb-3">
        휴대폰 번호 뒤 8자리를 입력하고 스캔 파일을 올리세요.
      </div>

      <input
        className="w-full mb-3 rounded border px-3 py-2 text-sm bg-neutral-900 text-neutral-100"
        placeholder="예: 12345678"
        value={enrollmentId}
        onChange={(e) => setEnrollmentId(e.target.value)}
      />

      <button
        className="w-full rounded-lg bg-neutral-100 px-4 py-2 text-sm text-neutral-950"
        onClick={() => inputRef.current?.click()}
      >
        스캔 파일 선택
      </button>

      <input
        ref={inputRef}
        type="file"
        className="hidden"
        onChange={(e) => {
          const f = e.target.files?.[0];
          if (f) uploadMut.mutate(f);
        }}
      />

      <div className="mt-2 text-xs text-neutral-400">
        {uploadMut.isPending
          ? "업로드 중입니다. 잠시만 기다려주세요."
          : "업로드 후 자동으로 인식·채점이 시작됩니다."}
      </div>
    </div>
  );
}


==========================================================================================
# FILE: components/AdminOmrUploadSection.tsx
==========================================================================================
// PATH: src/features/submissions/components/AdminOmrUploadSection.tsx
/**
 * AdminOmrUploadSection - 조교용 업로드 작업대 (단건/다건)
 * - 입력칸 없음
 * - 드롭/선택만 하면 서버가 제출을 생성하고 워커 파이프라인 돌림
 * - 엔드포인트 후보를 여러 개 시도(404면 자동 fallback)
 */

import { useMemo, useRef, useState } from "react";
import api from "@/shared/api/axios";
import axios from "axios";

type Props = {
  examId: number;
  onUploaded?: () => void;
};

type UploadResult = {
  ok: boolean;
  message: string;
  created?: number; // created submissions count (if backend returns)
};

const ACCEPT = [
  "image/*",
  "application/pdf",
].join(",");

function humanizeBytes(bytes: number) {
  if (!Number.isFinite(bytes) || bytes <= 0) return "-";
  const units = ["B", "KB", "MB", "GB"];
  let v = bytes;
  let i = 0;
  while (v >= 1024 && i < units.length - 1) {
    v /= 1024;
    i += 1;
  }
  return `${v.toFixed(i === 0 ? 0 : 1)} ${units[i]}`;
}

async function postWithFallback(examId: number, form: FormData) {
  /**
   * ✅ 프로젝트마다 엔드포인트가 다를 수 있어서 후보를 순서대로 시도한다.
   * - 404면 다음 후보로 넘어감
   * - 400/403/500은 그대로 throw (진짜 에러)
   */
  const candidates = [
    // 가장 흔한 형태들
    `/submissions/exams/${examId}/omr/upload/`,
    `/submissions/exams/${examId}/omr/batch/`,
    `/submissions/exams/${examId}/omr/files/`,
    `/submissions/exams/${examId}/omr/`, // 혹시 multipart도 받도록 구현한 경우
  ];

  let last404: any = null;

  for (const url of candidates) {
    try {
      const res = await api.post(url, form, {
        headers: { "Content-Type": "multipart/form-data" },
      });
      return res;
    } catch (e: any) {
      if (axios.isAxiosError(e) && e.response?.status === 404) {
        last404 = e;
        continue;
      }
      throw e;
    }
  }

  // 후보 전부 404
  throw last404 ?? new Error("업로드 엔드포인트를 찾지 못했습니다 (404).");
}

export default function AdminOmrUploadSection({ examId, onUploaded }: Props) {
  const inputRef = useRef<HTMLInputElement | null>(null);

  const [files, setFiles] = useState<File[]>([]);
  const [busy, setBusy] = useState(false);
  const [result, setResult] = useState<UploadResult | null>(null);

  const totalBytes = useMemo(() => files.reduce((t, f) => t + (f.size || 0), 0), [files]);

  const canSubmit = useMemo(() => {
    return Number.isFinite(examId) && examId > 0 && files.length > 0 && !busy;
  }, [examId, files.length, busy]);

  const pickFiles = (list: FileList | null) => {
    if (!list) return;
    const arr = Array.from(list);
    // 중복명+사이즈 기준으로 대충 dedupe
    const key = (f: File) => `${f.name}__${f.size}`;
    const map = new Map<string, File>();
    for (const f of [...files, ...arr]) map.set(key(f), f);
    setFiles(Array.from(map.values()));
    setResult(null);
  };

  const onDrop = (ev: React.DragEvent) => {
    ev.preventDefault();
    ev.stopPropagation();
    pickFiles(ev.dataTransfer.files);
  };

  const upload = async () => {
    if (!canSubmit) return;

    setBusy(true);
    setResult(null);

    try {
      const form = new FormData();
      // 백엔드 구현마다 키가 다르니, 가장 흔한 형태로 "files" 반복 + "file"도 추가
      files.forEach((f) => form.append("files", f));
      if (files.length === 1) form.append("file", files[0]);

      const res = await postWithFallback(examId, form);

      // 서버가 반환하는 형태가 제각각이라 안전하게 파싱
      const data = res.data as any;

      const created =
        Number(data?.created) ||
        Number(data?.created_count) ||
        Number(data?.count) ||
        (Array.isArray(data?.items) ? data.items.length : 0) ||
        (Array.isArray(data) ? data.length : 0) ||
        undefined;

      setResult({
        ok: true,
        message:
          created && created > 0
            ? `업로드 완료 · 제출 ${created}건 생성됨`
            : "업로드 완료 · 제출 생성/처리는 서버에서 진행됩니다.",
        created,
      });

      setFiles([]);
      onUploaded?.();
    } catch (e: any) {
      const status = e?.response?.status;
      const detail = e?.response?.data?.detail;

      let msg =
        detail ||
        e?.message ||
        "업로드 실패. 서버 엔드포인트/권한/파일 형식을 확인하세요.";

      if (status === 403) {
        msg = detail || "권한이 없습니다. (Admin/Teacher 권한 필요)";
      } else if (status === 400) {
        msg = detail || "요청 값이 올바르지 않습니다. 파일 형식을 확인하세요.";
      } else if (status === 404) {
        msg =
          "업로드 API를 찾지 못했습니다(404). " +
          "백엔드에서 업로드 엔드포인트 경로를 확인하세요.";
      }

      setResult({ ok: false, message: String(msg) });
    } finally {
      setBusy(false);
    }
  };

  return (
    <div className="rounded border border-[var(--border-divider)] bg-[var(--bg-surface)] p-4 space-y-3">
      <div className="flex items-start justify-between gap-3">
        <div>
          <div className="text-sm font-semibold text-[var(--text-primary)]">
            OMR 스캔 업로드
          </div>
          <div className="text-xs text-[var(--text-muted)]">
            스캔 이미지/PDF를 업로드하면 서버가 <b>식별 → 답안추출 → 채점</b>을 자동 수행합니다.
          </div>
        </div>

        <div className="text-right text-xs text-[var(--text-muted)]">
          <div>선택: {files.length}개</div>
          <div>용량: {humanizeBytes(totalBytes)}</div>
        </div>
      </div>

      {/* Dropzone */}
      <div
        onDragOver={(e) => {
          e.preventDefault();
          e.stopPropagation();
        }}
        onDrop={onDrop}
        className={[
          "rounded-lg border border-dashed p-4 transition",
          "bg-[var(--bg-surface-soft)]",
        ].join(" ")}
      >
        <div className="text-sm font-semibold text-[var(--text-primary)]">
          파일을 여기로 드롭
        </div>
        <div className="mt-1 text-xs text-[var(--text-muted)]">
          지원: 이미지(JPG/PNG) / PDF · 여러 장 한번에 업로드 가능
        </div>

        <div className="mt-3 flex flex-wrap items-center gap-2">
          <button
            type="button"
            className="btn"
            disabled={busy}
            onClick={() => inputRef.current?.click()}
          >
            파일 선택
          </button>

          <button
            type="button"
            className="btn-primary"
            disabled={!canSubmit}
            onClick={() => void upload()}
          >
            {busy ? "업로드 중..." : "업로드 시작"}
          </button>

          {files.length > 0 && !busy && (
            <button
              type="button"
              className="btn"
              onClick={() => {
                setFiles([]);
                setResult(null);
              }}
            >
              선택 초기화
            </button>
          )}
        </div>

        <input
          ref={inputRef}
          type="file"
          accept={ACCEPT}
          multiple
          className="hidden"
          onChange={(e) => pickFiles(e.target.files)}
          disabled={busy}
        />

        {files.length > 0 && (
          <div className="mt-3 max-h-40 overflow-auto rounded border bg-white/70">
            {files.map((f, idx) => (
              <div key={`${f.name}-${f.size}-${idx}`} className="flex items-center justify-between gap-3 px-3 py-2 border-b last:border-b-0">
                <div className="text-xs text-[var(--text-secondary)] truncate">
                  {f.name}
                </div>
                <div className="text-[11px] text-[var(--text-muted)]">
                  {humanizeBytes(f.size)}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Result */}
      {result && (
        <div
          className={[
            "rounded border p-3 text-sm",
            result.ok
              ? "border-emerald-600/30 bg-emerald-600/10 text-emerald-800"
              : "border-red-600/30 bg-red-600/10 text-red-700",
          ].join(" ")}
        >
          {result.message}
        </div>
      )}

      <div className="text-[11px] text-[var(--text-muted)]">
        ※ 학생 식별번호는 <b>OMR 마킹</b>으로 처리됩니다. 조교가 입력하지 않습니다.
      </div>
    </div>
  );
}


==========================================================================================
# FILE: components/AdminSubmissionDetailModal.tsx
==========================================================================================
// src/features/submissions/components/AdminSubmissionDetailModal.tsx
import { useEffect, useState } from "react";
import { useQueryClient, useMutation } from "@tanstack/react-query";
import { useSubmissionPolling } from "../hooks/useSubmissionPolling";
import SubmissionStatusBadge from "./SubmissionStatusBadge";
import {
  retryAnySubmission,
  fetchSubmissionManualReview,
  saveSubmissionManualReview,
} from "../api/adminSubmissions";

export default function AdminSubmissionDetailModal({
  open,
  onClose,
  submissionId,
  onGoResults,
}: {
  open: boolean;
  onClose: () => void;
  submissionId: number;
  examId?: number;
  onGoResults?: (examId: number) => void;
}) {
  const qc = useQueryClient();
  const poll = useSubmissionPolling(submissionId, open);
  const submission = poll.data;

  const [answers, setAnswers] = useState<any[]>([]);

  const load = useMutation({
    mutationFn: () => fetchSubmissionManualReview(submissionId),
    onSuccess: (d) => setAnswers(d?.answers ?? []),
  });

  useEffect(() => {
    if (open) load.mutate();
  }, [open]);

  const save = useMutation({
    mutationFn: () =>
      saveSubmissionManualReview(submissionId, {
        answers: answers.map((a) => ({
          question_id: a.question_id,
          question_no: a.question_no,
          answer: a.answer,
        })),
      }),
    onSuccess: () => qc.invalidateQueries(),
  });

  if (!open || !submission) return null;

  return (
    <div className="fixed inset-0 z-50 bg-black/60 flex items-center justify-center p-4">
      <div className="bg-[var(--bg-surface)] w-full max-w-4xl rounded-xl border">
        <div className="flex items-center justify-between px-4 py-3 border-b">
          <div className="text-sm font-semibold">Submission #{submission.id}</div>
          <button className="text-xs" onClick={onClose}>닫기</button>
        </div>

        <div className="p-4 space-y-4">
          <SubmissionStatusBadge status={submission.status} />

          {submission.meta?.manual_review?.required && (
            <>
              <div className="text-xs text-[var(--text-muted)]">
                일부 답안이 인식되지 않았습니다. 필요한 부분만 수정하세요.
              </div>

              <table className="table">
                <tbody>
                  {answers.map((a, i) => (
                    <tr key={i}>
                      <td>{a.question_no ?? a.question_id}</td>
                      <td>
                        <input
                          className="form-input"
                          value={a.answer ?? ""}
                          onChange={(e) =>
                            setAnswers((prev) =>
                              prev.map((p, idx) =>
                                idx === i ? { ...p, answer: e.target.value } : p
                              )
                            )
                          }
                        />
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>

              <button className="btn-primary" onClick={() => save.mutate()}>
                저장 후 재채점
              </button>
            </>
          )}

          {submission.status === "failed" && (
            <button className="btn" onClick={() => retryAnySubmission(submissionId)}>
              다시 처리
            </button>
          )}

          {submission.status === "done" && onGoResults && (
            <button className="btn-primary" onClick={() => onGoResults(submission.target_id)}>
              결과 보기
            </button>
          )}
        </div>
      </div>
    </div>
  );
}


==========================================================================================
# FILE: components/AdminSubmissionsPanel.tsx
==========================================================================================
import { useQuery } from "@tanstack/react-query";
import { fetchExamSubmissions } from "../api/adminSubmissionsApi";

export default function AdminSubmissionsPanel({
  examId,
  onGoResults,
}: {
  examId: number;
  onGoResults?: (examId: number) => void;
}) {
  const q = useQuery({
    queryKey: ["exam-submissions", examId],
    queryFn: () => fetchExamSubmissions(examId),
    refetchInterval: 3000, // 실운영용: 자동 갱신
  });

  if (q.isLoading) {
    return <div className="text-sm text-muted">제출 목록 불러오는 중…</div>;
  }

  if (q.isError) {
    return (
      <div className="rounded border border-red-600/30 bg-red-600/10 p-4 text-sm text-red-700">
        제출 목록 조회 실패. (submissions API 경로 확인 필요)
      </div>
    );
  }

  const rows = q.data ?? [];

  return (
    <div className="rounded-xl border border-neutral-800 bg-neutral-950 p-4 space-y-3">
      <div className="flex justify-between items-center">
        <div className="text-sm font-semibold text-neutral-100">
          제출 / 처리 상태
        </div>

        <button
          onClick={() => q.refetch()}
          className="text-xs px-3 py-1 rounded bg-neutral-800 text-neutral-200"
        >
          새로고침
        </button>
      </div>

      {rows.length === 0 && (
        <div className="text-xs text-neutral-400">
          아직 제출된 OMR이 없습니다.
        </div>
      )}

      <div className="divide-y divide-neutral-800">
        {rows.map((r) => (
          <div
            key={r.id}
            className="flex justify-between items-center py-2 text-xs text-neutral-200"
          >
            <div>
              <div className="font-medium">
                {r.student_name} (#{r.enrollment_id})
              </div>
              <div className="text-neutral-400">
                {new Date(r.created_at).toLocaleString()}
              </div>
            </div>

            <div className="flex items-center gap-4">
              <span>
                {r.status === "pending" && "대기"}
                {r.status === "processing" && "처리중"}
                {r.status === "done" && "완료"}
                {r.status === "failed" && "실패"}
              </span>

              <span className="font-semibold">
                {r.score ?? "-"}
              </span>
            </div>
          </div>
        ))}
      </div>

      {rows.some((r) => r.status === "done") && onGoResults && (
        <div className="pt-3 text-right">
          <button
            onClick={() => onGoResults(examId)}
            className="px-4 py-2 rounded bg-emerald-600 text-white text-sm font-semibold"
          >
            결과 보기
          </button>
        </div>
      )}
    </div>
  );
}


==========================================================================================
# FILE: components/ManualIdentifyForm.tsx
==========================================================================================
// components/ManualIdentifyForm.tsx
import { useState } from "react";
import { manualIdentifySubmission } from "../api/submissions";

export default function ManualIdentifyForm({
  submissionId,
}: {
  submissionId: number;
}) {
  const [value, setValue] = useState("");

  return (
    <div className="flex gap-2">
      <input
        className="w-32 rounded border px-2 py-1 text-sm"
        placeholder="enrollment_id"
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />
      <button
        className="rounded bg-black px-3 py-1 text-sm text-white"
        onClick={() =>
          manualIdentifySubmission(submissionId, Number(value))
        }
      >
        식별
      </button>
    </div>
  );
}


==========================================================================================
# FILE: components/ManualReviewBadge.tsx
==========================================================================================
// PATH: src/features/submissions/components/ManualReviewBadge.tsx
export default function ManualReviewBadge({
  required,
  reasons,
}: {
  required: boolean;
  reasons?: string[];
}) {
  if (!required) {
    return (
      <span className="inline-flex items-center rounded-full border border-neutral-800 bg-neutral-950 px-2 py-1 text-xs text-neutral-400">
        자동 처리
      </span>
    );
  }

  return (
    <span
      className="inline-flex items-center gap-1 rounded-full border border-yellow-800 bg-yellow-950 px-2 py-1 text-xs text-yellow-200"
      title={(reasons ?? []).join(", ")}
    >
      ⚠️ 수동 검토 필요{reasons?.length ? ` (${reasons.length})` : ""}
    </span>
  );
}


==========================================================================================
# FILE: components/OmrTemplateGeneratorPanel.tsx
==========================================================================================
// ====================================================================================================
// FILE: src/features/submissions/components/OmrTemplateGeneratorPanel.tsx
// ====================================================================================================
/**
 * OMR 답안지 생성 (프린트/그림판용)
 * - 서버 단일진실(sheet/questions) 기준
 * - PDF/PNG 다운로드
 */
import { useMutation } from "@tanstack/react-query";
import api from "@/shared/api/axios";

export default function OmrTemplateGeneratorPanel({ examId }: { examId: number }) {
  const gen = useMutation({
    mutationFn: async (fmt: "pdf" | "png") => {
      const res = await api.post(
        `/exams/${examId}/omr-template/`,
        { format: fmt },
        { responseType: "blob" }
      );
      const url = URL.createObjectURL(res.data);
      const a = document.createElement("a");
      a.href = url;
      a.download = `exam_${examId}_omr.${fmt}`;
      a.click();
      URL.revokeObjectURL(url);
    },
  });

  return (
    <div className="rounded-xl border border-neutral-800 bg-neutral-950 p-4">
      <div className="mb-2 text-sm font-semibold text-neutral-100">OMR 답안지 생성</div>
      <div className="text-xs text-neutral-400 mb-3">
        프린트 후 그림판 마킹 → 업로드 테스트 가능
      </div>
      <div className="flex gap-2">
        <button
          className="rounded-lg bg-neutral-100 px-3 py-2 text-sm text-neutral-950 disabled:opacity-40"
          onClick={() => gen.mutate("pdf")}
          disabled={gen.isPending}
        >
          PDF 다운로드
        </button>
        <button
          className="rounded-lg border border-neutral-800 bg-neutral-900 px-3 py-2 text-sm text-neutral-100 disabled:opacity-40"
          onClick={() => gen.mutate("png")}
          disabled={gen.isPending}
        >
          PNG 다운로드
        </button>
      </div>
    </div>
  );
}


==========================================================================================
# FILE: components/SubmissionStatusBadge.tsx
==========================================================================================
// ====================================================================================================
// FILE: src/features/submissions/components/SubmissionStatusBadge.tsx
// ====================================================================================================
import type { SubmissionStatus } from "@/features/submissions/types";
import { SUBMISSION_STATUS_COLOR, SUBMISSION_STATUS_LABEL } from "@/features/submissions/statusMaps";

const COLOR_CLASS: Record<string, string> = {
  gray: "bg-neutral-800 text-neutral-200 border-neutral-700",
  blue: "bg-blue-950 text-blue-200 border-blue-800",
  indigo: "bg-indigo-950 text-indigo-200 border-indigo-800",
  yellow: "bg-yellow-950 text-yellow-200 border-yellow-800",
  green: "bg-emerald-950 text-emerald-200 border-emerald-800",
  red: "bg-red-950 text-red-200 border-red-800",
};

export default function SubmissionStatusBadge({
  status,
}: {
  status: SubmissionStatus | "graded" | null;
}) {
  if (!status) {
    return (
      <span className="inline-flex items-center rounded-full border border-neutral-800 bg-neutral-900 px-2 py-1 text-xs text-neutral-300">
        -
      </span>
    );
  }
  const key = (SUBMISSION_STATUS_COLOR as any)[status] ?? "gray";
  const cls = COLOR_CLASS[key] ?? COLOR_CLASS.gray;
  return (
    <span className={`inline-flex items-center rounded-full border px-2 py-1 text-xs ${cls}`}>
      {(SUBMISSION_STATUS_LABEL as any)[status] ?? status}
    </span>
  );
}


==========================================================================================
# FILE: dev/SubmissionTestPanel.tsx
==========================================================================================
// ====================================================================================================
// FILE: src/features/submissions/dev/SubmissionTestPanel.tsx
// (선택: 즉시 체감 테스트 버튼 유지)
// ====================================================================================================
import { createSubmission } from "../api";

export async function handleUploadTest(file: File, examId: number) {
  const formData = new FormData();
  formData.append("enrollment_id", "1");
  formData.append("target_type", "exam");
  formData.append("target_id", String(examId));
  formData.append("source", "omr_scan");
  formData.append("file", file);
  return createSubmission(formData);
}


==========================================================================================
# FILE: hooks/useAdminSubmissions.ts
==========================================================================================
// PATH: src/features/submissions/hooks/useAdminSubmissions.ts
import { useQuery } from "@tanstack/react-query";
import type { Submission, SubmissionStatus } from "@/features/submissions/types";
import { fetchAdminSubmissions } from "@/features/submissions/api/adminSubmissions";

export function useAdminSubmissions(params: {
  examId?: number;
  enrollmentId?: number;
  status?: SubmissionStatus;
  enabled?: boolean;
  limit?: number;
  polling?: boolean;
}) {
  const enabled = params.enabled ?? true;
  const polling = params.polling ?? true;

  return useQuery<Submission[]>({
    queryKey: ["admin-submissions", params.examId, params.enrollmentId, params.status, params.limit],
    queryFn: () =>
      fetchAdminSubmissions({
        examId: params.examId,
        enrollmentId: params.enrollmentId,
        status: params.status,
        limit: params.limit ?? 50,
      }),
    enabled: enabled,
    refetchInterval: polling ? 2000 : false,
  });
}


==========================================================================================
# FILE: hooks/useSubmissionPolling.ts
==========================================================================================
// ====================================================================================================
// FILE: src/features/submissions/hooks/useSubmissionPolling.ts
// ====================================================================================================
import { useQuery } from "@tanstack/react-query";
import { fetchSubmission } from "../api";
import { Submission } from "../types";

const TERMINAL_STATUS = ["done", "failed", "graded"] as const;

export function useSubmissionPolling(submissionId?: number, enabled: boolean = true) {
  return useQuery<Submission>({
    queryKey: ["submission", submissionId],
    queryFn: () => fetchSubmission(submissionId!),
    enabled: enabled && Number.isFinite(submissionId),
    refetchInterval: (data) => {
      if (!data) return 2000;
      return (TERMINAL_STATUS as readonly string[]).includes(data.status) ? false : 2000;
    },
  });
}
